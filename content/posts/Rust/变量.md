---
title: 变量
date: 2025-02-03
categories:
  - Rust
tags:
  - Note
---

## 变量的绑定与解构

**手动设置可变性**

在rust语言中可以手动设置变量的可变性。这是灵活性和安全性的结合。但是这样肯定会在编码的过程中付出更多的思考，但这也是**权衡**之后做出的选择。

**变量绑定**

在rust语言中变量和标识符之间是一种绑定关系，直接是**所有权**的改变。
简单来说任何一块有意义的内存都有所属，而且这个关系是唯一的。
这样就以为这变量和内存之间只能真诚的进行1v1了。

## 变量可变性

rust语言的变量在默认情况下是**不可变的**，但是可以通过`mut`关键字让变量变为可变的。
 下面我们进行编码进行实践操作
 ```rust
 fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

我们可以预想的到这样的代码会报错
![image.png|675](https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240106215132.png)
由于我们对x发生了两次赋值。我们遵循报错给出的建议，使用`mut`对变量进行修饰。
这样由于显示的规定变量是否可以被修改，在多线程的编程过程中能让我们少死很多脑细胞，对程序员也是一种保护。

```rust
let mut x=5;
   println!("the value of x is:{}",x);
   x=6;
   println!("the value of x is:{}",x);
```

这次非常的顺利运行结果没有任何问题。

![image.png|675](https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240106220106.png)

## 使用下划线忽略未使用的变量

在日常编程的过程中经常会发出“变量从未使用”的警告，如果此时你正在设计一个项目，你可能会拥有很多的未使用的变量。此时你可以使用**下划线作为变量的开头，屏蔽警告。**

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

这样的话就不会对未使用的变形进行警告了。

## 变量结构


`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

## 变量与常量之间的差距

首先我们需要明确的说：`常量不仅仅是不可改变的变量`。
- 首先常量不能够使用`mut`，这一关键字去改变他的性质。**常量不仅默认不可改变，而且自始至终都不可改变。**
- 常量使用**const**而不是**let**进行标识。并且值的**类型**必须进行标注。

常量可以在任意作用域内声明，而且生命期贯穿整个软件的执行期。

```rust
const MAX_POINTS: u32 = 100_000;

```

## 变量遮蔽

我们可以认为在作用域内同名的变量只能存在一份，如果有新声明的那么之前的就会被冲掉，就以新声明的为准。但是在这个过程中可能会发生赋值类型的转变。在这个过程中要**保证**不发生冲突。

