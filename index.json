[{"content":"Using gdb 平时我们用的调试工具其实都是图形化后的gdb，使用起来非常的方便，但是熟悉原生的gdb会使我们的效率进一步提升。我认为学习好用gdb调试是一项非常重要的技能。\n编译并启动 ==make qemu-gdb==\n使用上述命令编译项目并且直接以调试模式启动。但是这个项目启动的其实是在本地的一个远程gdb，通过另一个窗口进行调试。 下面有几个关于系统调用的小问题\nLooking at the backtrace output, which function called syscall?\n显然是usertrap（）\nWhat is the value of p-\u0026gt;trapframe-\u0026gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.) 通过提示找到trapframe的地址，在kernel/proc.h中找到a7寄存器对应的偏移地址。 把168换算成16进制 尝试着打印0x87f560a8 这个就是寄存器a7的值。其代表的具体含义通过所给的提示到对应文件中查找之后也是十分的明了。 应该就是系统的调用号。\nWhat was the previous mode that the CPU was in?\nspp位表示其在什么状态。 通过图示得出，spp在二进制的第8bit. 由图可知8bit是0，所以之前是用户状态 。 System call tracing Attack xv6 这个task主要是利用xv6故意留下的bug然后获取到销毁内存但是保留了脏页的数据。然后通过一些比较hack的手段把字段给找出来。\npage组成 上图是一个简化的逻辑页表，下一个实验也会用到，这里理顺一下逻辑有利于分析代码的组成。 上图是地址转化的细节。 页表项（PTE）包含标志位，告诉硬件应该如何使用这些虚拟地址。 这些相关位的定义都在(kernel/riscv.h)中\n书中这一段包含的最重要的信息是xv6采用了sv39的riscv架构。 这个很好的解释了sv39的组成。显然sv39是三级页表的架构。\n","permalink":"https://jialog.top/posts/os/lab1-xv6--system-calls/","summary":"\u003ch2 id=\"using-gdb\"\u003eUsing gdb\u003c/h2\u003e\n\u003cp\u003e平时我们用的调试工具其实都是图形化后的gdb，使用起来非常的方便，但是熟悉原生的gdb会使我们的效率进一步提升。我认为学习好用gdb调试是一项非常重要的技能。\u003c/p\u003e\n\u003ch3 id=\"编译并启动\"\u003e编译并启动\u003c/h3\u003e\n\u003cp\u003e==make qemu-gdb==\u003c/p\u003e\n\u003cp\u003e使用上述命令\u003cstrong\u003e编译项目\u003c/strong\u003e并且直接以\u003cstrong\u003e调试\u003c/strong\u003e模式启动。但是这个项目启动的其实是在本地的一个远程gdb，通过另一个窗口进行调试。\n\u003cimg alt=\"PixPin_2025-02-25_13-54-10.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_13-54-10.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下面有几个关于系统调用的小问题\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLooking at the backtrace output, which function called syscall?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-25_16-13-11.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-13-11.png\"\u003e\n\u003cimg alt=\"PixPin_2025-02-25_16-19-46.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-19-46.png\"\u003e\n显然是usertrap（）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat is the value of p-\u0026gt;trapframe-\u0026gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)\u003c/strong\u003e\n\u003cimg alt=\"PixPin_2025-02-25_16-26-31.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-26-31.png\"\u003e\n通过提示找到trapframe的地址，在kernel/proc.h中找到a7寄存器对应的偏移地址。\n\u003cimg alt=\"PixPin_2025-02-25_16-28-03.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-28-03.png\"\u003e\n把168换算成16进制\n\u003cimg alt=\"PixPin_2025-02-25_16-29-13.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-29-13.png\"\u003e\n尝试着打印\u003cstrong\u003e0x87f560a8\u003c/strong\u003e\n\u003cimg alt=\"PixPin_2025-02-25_16-30-11.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-30-11.png\"\u003e\n这个就是寄存器a7的值。其代表的具体含义通过所给的提示到对应文件中查找之后也是十分的明了。\n\u003cimg alt=\"PixPin_2025-02-25_16-32-21.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-32-21.png\"\u003e\n应该就是系统的调用号。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat was the previous mode that the CPU was in?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-25_16-43-14.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_16-43-14.png\"\u003e\nspp位表示其在什么状态。 通过图示得出，spp在二进制的第8bit.\n\u003cimg alt=\"PixPin_2025-02-25_17-10-18.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-10-18.png\"\u003e\n由图可知8bit是0，所以之前是用户状态 。\n\u003cimg alt=\"PixPin_2025-02-25_17-26-23.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-26-23.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-25_17-26-05.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-25_17-26-05.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"system-call-tracing\"\u003eSystem call tracing\u003c/h2\u003e\n\u003ch2 id=\"attack-xv6\"\u003eAttack xv6\u003c/h2\u003e\n\u003cp\u003e这个task主要是利用xv6故意留下的bug然后获取到销毁内存但是保留了脏页的数据。然后通过一些比较hack的手段把字段给找出来。\u003c/p\u003e\n\u003ch3 id=\"page组成\"\u003epage组成\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-28_20-58-24.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-28_20-58-24.png\"\u003e\n上图是一个简化的逻辑页表，下一个实验也会用到，这里理顺一下逻辑有利于分析代码的组成。\n\u003cimg alt=\"PixPin_2025-02-28_21-01-20.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-28_21-01-20.png\"\u003e\n上图是地址转化的细节。\n页表项（PTE）包含标志位，告诉硬件应该如何使用这些虚拟地址。\u003cimg alt=\"PixPin_2025-03-02_10-35-10.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-02_10-35-10.png\"\u003e\n这些相关位的定义都在(kernel/riscv.h)中\u003c/p\u003e","title":"Lab1 Xv6 \u0026\u0026 system calls"},{"content":"变量的绑定与解构 手动设置可变性\n在rust语言中可以手动设置变量的可变性。这是灵活性和安全性的结合。但是这样肯定会在编码的过程中付出更多的思考，但这也是权衡之后做出的选择。\n变量绑定\n在rust语言中变量和标识符之间是一种绑定关系，直接是所有权的改变。 简单来说任何一块有意义的内存都有所属，而且这个关系是唯一的。 这样就以为这变量和内存之间只能真诚的进行1v1了。\n变量可变性 rust语言的变量在默认情况下是不可变的，但是可以通过mut关键字让变量变为可变的。 下面我们进行编码进行实践操作\nfn main() { let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); } 我们可以预想的到这样的代码会报错 由于我们对x发生了两次赋值。我们遵循报错给出的建议，使用mut对变量进行修饰。 这样由于显示的规定变量是否可以被修改，在多线程的编程过程中能让我们少死很多脑细胞，对程序员也是一种保护。\nlet mut x=5; println!(\u0026#34;the value of x is:{}\u0026#34;,x); x=6; println!(\u0026#34;the value of x is:{}\u0026#34;,x); 这次非常的顺利运行结果没有任何问题。\n使用下划线忽略未使用的变量 在日常编程的过程中经常会发出“变量从未使用”的警告，如果此时你正在设计一个项目，你可能会拥有很多的未使用的变量。此时你可以使用下划线作为变量的开头，屏蔽警告。\nfn main() { let _x = 5; let y = 10; } 这样的话就不会对未使用的变形进行警告了。\n变量结构 let 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：\nfn main() { let (a, mut b): (bool,bool) = (true, false); // a = true,不可变; b = false，可变 println!(\u0026#34;a = {:?}, b = {:?}\u0026#34;, a, b); b = true; assert_eq!(a, b); } 变量与常量之间的差距 首先我们需要明确的说：常量不仅仅是不可改变的变量。\n首先常量不能够使用mut，这一关键字去改变他的性质。常量不仅默认不可改变，而且自始至终都不可改变。 常量使用const而不是let进行标识。并且值的类型必须进行标注。 常量可以在任意作用域内声明，而且生命期贯穿整个软件的执行期。\nconst MAX_POINTS: u32 = 100_000; 变量遮蔽 我们可以认为在作用域内同名的变量只能存在一份，如果有新声明的那么之前的就会被冲掉，就以新声明的为准。但是在这个过程中可能会发生赋值类型的转变。在这个过程中要保证不发生冲突。\n","permalink":"https://jialog.top/posts/rust/%E5%8F%98%E9%87%8F/","summary":"\u003ch2 id=\"变量的绑定与解构\"\u003e变量的绑定与解构\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e手动设置可变性\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在rust语言中可以手动设置变量的可变性。这是灵活性和安全性的结合。但是这样肯定会在编码的过程中付出更多的思考，但这也是\u003cstrong\u003e权衡\u003c/strong\u003e之后做出的选择。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e变量绑定\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在rust语言中变量和标识符之间是一种绑定关系，直接是\u003cstrong\u003e所有权\u003c/strong\u003e的改变。\n简单来说任何一块有意义的内存都有所属，而且这个关系是唯一的。\n这样就以为这变量和内存之间只能真诚的进行1v1了。\u003c/p\u003e\n\u003ch2 id=\"变量可变性\"\u003e变量可变性\u003c/h2\u003e\n\u003cp\u003erust语言的变量在默认情况下是\u003cstrong\u003e不可变的\u003c/strong\u003e，但是可以通过\u003ccode\u003emut\u003c/code\u003e关键字让变量变为可变的。\n下面我们进行编码进行实践操作\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;The value of x is: \u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;The value of x is: \u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们可以预想的到这样的代码会报错\n\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240106215132.png\"\u003e\n由于我们对x发生了两次赋值。我们遵循报错给出的建议，使用\u003ccode\u003emut\u003c/code\u003e对变量进行修饰。\n这样由于显示的规定变量是否可以被修改，在多线程的编程过程中能让我们少死很多脑细胞，对程序员也是一种保护。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;the value of x is:\u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;the value of x is:\u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这次非常的顺利运行结果没有任何问题。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240106220106.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"使用下划线忽略未使用的变量\"\u003e使用下划线忽略未使用的变量\u003c/h2\u003e\n\u003cp\u003e在日常编程的过程中经常会发出“变量从未使用”的警告，如果此时你正在设计一个项目，你可能会拥有很多的未使用的变量。此时你可以使用\u003cstrong\u003e下划线作为变量的开头，屏蔽警告。\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e_x\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样的话就不会对未使用的变形进行警告了。\u003c/p\u003e","title":"变量"},{"content":"操作系统上的进程 背景回顾：有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入操作系统和应用程序的 “边界” 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。\n本讲内容：操作系统上的进程\n操作系统上的第一个进程 UNIX/Linux 进程管理 API: fork, execve, exit fork（） 理解 fork(): fork() 会完整复制状态机；新创建的状态机返回值为 0，执行 fork() 的进程会返回子进程的进程号。同时，操作系统中的进程是并行执行的。程序的精确行为并不显然——model checker 可以帮助我们理解它。\n在这个例子中，我们还发现执行 ./a.out 打印的行数和 ./a.out | wc -l 得到的行数不同。根据 “机器永远是对的” 的原则，我们可以通过提出假设 (libc 缓冲区影响) 求证、对比 strace 系统调用序列等方式，最终理解背后的原因。标准输入输出的缓冲控制可以通过 setbuf(3) 和 stdbuf(1) 实现。\nexecve（） exit（） ","permalink":"https://jialog.top/posts/os/%E8%99%9A%E6%8B%9F%E5%8C%96--%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86apifork-execve-exit/","summary":"\u003ch1 id=\"操作系统上的进程\"\u003e操作系统上的进程\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e背景回顾\u003c/strong\u003e：有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入操作系统和应用程序的 “边界” 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本讲内容\u003c/strong\u003e：操作系统上的进程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统上的第一个进程\u003c/li\u003e\n\u003cli\u003eUNIX/Linux 进程管理 API: fork, execve, exit\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"fork\"\u003efork（）\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-03_14-37-19.png600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-37-19.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-03_14-51-04.png600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-51-04.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e理解 fork()\u003c/strong\u003e: fork() 会完整复制状态机；新创建的状态机返回值为 0，执行 fork() 的进程会返回子进程的进程号。同时，操作系统中的进程是并行执行的。程序的精确行为并不显然——model checker 可以帮助我们理解它。\u003c/p\u003e\n\u003cp\u003e在这个例子中，我们还发现执行 \u003ccode\u003e./a.out\u003c/code\u003e 打印的行数和 \u003ccode\u003e./a.out | wc -l\u003c/code\u003e 得到的行数不同。根据 “机器永远是对的” 的原则，我们可以通过提出假设 (libc 缓冲区影响) 求证、对比 strace 系统调用序列等方式，最终理解背后的原因。标准输入输出的缓冲控制可以通过 setbuf(3) 和 stdbuf(1) 实现。\u003c/p\u003e\n\u003ch2 id=\"execve\"\u003eexecve（）\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-03_14-54-18.png|525\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-54-18.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-02-03_14-55-00.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-02-03_14-55-00.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"exit\"\u003eexit（）\u003c/h2\u003e","title":"虚拟化--进程管理API：fork, execve, exit"},{"content":"xv6 启动！ 万事开头难！ 这是我所用的开发环境，Kubuntu+VsCode，这样的环境对我来说是比较舒服的，也是比较好用的在实际使用的过程中我没感觉ubuntu和kubuntu有任何的区别，反正我也不在乎桌面，我只在终端里用。 用debian系的有一个好处就是软件生态真的很不错，可别是最新的，版本什么的直接用apt都能直接获得，虽然不想archwiki那样完善，但是Google一下基本上问题也都能解决。\n一个很有意思的工具 bear 我相信有很多同学在用vscode看项目代码的时候会发现，全是红线，项目变得根本就不可读，无法跳转，更无法获得依赖关系，只能把vscode当一个能用鼠标的阉割版的vim用。我们可以获取编译的命令行，然后让vscode知道然后把这些报错给消掉 1.make -nB 当然可以手动获取编译选项，但是这样也是比较复杂的而且十分的低效 2.bear 善于使用工具，君子性非异也，善假于物也。用bear把编译过程包起来就能自动获取编译选项。\n如何在vscode中debug ==官方非GUI界面==\nmake qemu-gdb 之后系统会在本地启动一个gdb，另起一个终端使用gdb连接。 到这就说明gdb启动成功了，但是后面会有一个小小的坑。\nType \u0026ldquo;apropos word\u0026rdquo; to search for commands related to \u0026ldquo;word\u0026rdquo;. warning: File \u0026ldquo;/home/learn_code/xv6-labs-2024/.gdbinit\u0026rdquo; auto-loading has been declined by your `auto-load safe-path\u0026rsquo; set to \u0026ldquo;$debugdir:$datadir/auto-load:/home/learn_code/xv6-riscv/.gdbinit\u0026rdquo;. To enable execution of this file add add-auto-load-safe-path /home/learn_code/xv6-labs-2024/.gdbinit line to your configuration file \u0026ldquo;/root/.config/gdb/gdbinit\u0026rdquo;. To completely disable this security protection add set auto-load safe-path / line to your configuration file \u0026ldquo;/root/.config/gdb/gdbinit\u0026rdquo;.\n当你启动gdb的时候可能会出现以上错误 这个按照上面说明的路径添加一个文件即可 如果使用gdb会有如上报错。 因为xv6的架构是risc-v的所以要是用这个支持多架构的gdb成功启动。\n==配置vscode使用图形化界面==\nlanch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xv6debug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/kernel/kernel\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;127.0.0.1:25000\u0026#34;, //见.gdbinit 中 target remote xxxx:xx 一定要一 一对应 \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb-multiarch\u0026#34;, // which gdb-multiarch \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;xv6build\u0026#34; } ] } task.json\n// xv6-riscv/.vscode/tasks.json { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;xv6build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;isBackground\u0026#34;: true, \u0026#34;command\u0026#34;: \u0026#34;make qemu-gdb\u0026#34;, \u0026#34;problemMatcher\u0026#34;: [ { \u0026#34;pattern\u0026#34;: [ { \u0026#34;regexp\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;file\u0026#34;: 1, \u0026#34;location\u0026#34;: 2, \u0026#34;message\u0026#34;: 3 } ], \u0026#34;background\u0026#34;: { \u0026#34;beginsPattern\u0026#34;: \u0026#34;.*Now run \u0026#39;gdb\u0026#39; in another window.\u0026#34;, // 要对应编译成功后,一句echo的内容. 此处对应 Makefile Line:170 \u0026#34;endsPattern\u0026#34;: \u0026#34;.\u0026#34; } } ] } ] } set confirm off set architecture riscv:rv64 @REM target remote 127.0.0.1:25000 symbol-file kernel/kernel set disassemble-next-line auto set riscv use-compressed-breakpoints yes 要将gitinit里面的端口注释掉不然会发生冲突。 然后直接f5就可以调试了。\n","permalink":"https://jialog.top/posts/os/xv6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB/","summary":"\u003ch2 id=\"xv6-启动\"\u003exv6 启动！\u003c/h2\u003e\n\u003cp\u003e万事开头难！\n\u003cimg alt=\"PixPin_2024-12-27_21-38-12.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2024-12-27_21-38-12.png\"\u003e\n这是我所用的开发环境，Kubuntu+VsCode，这样的环境对我来说是比较舒服的，也是比较好用的在实际使用的过程中我没感觉ubuntu和kubuntu有任何的区别，反正我也不在乎桌面，我只在终端里用。\n用debian系的有一个好处就是软件生态真的很不错，可别是最新的，版本什么的直接用apt都能直接获得，虽然不想archwiki那样完善，但是Google一下基本上问题也都能解决。\u003c/p\u003e\n\u003ch3 id=\"一个很有意思的工具-bear\"\u003e一个很有意思的工具 bear\u003c/h3\u003e\n\u003cp\u003e我相信有很多同学在用vscode看项目代码的时候会发现，全是红线，项目变得根本就不可读，无法跳转，更无法获得依赖关系，只能把vscode当一个能用鼠标的阉割版的vim用。我们可以获取编译的命令行，然后让vscode知道然后把这些报错给消掉\n\u003cstrong\u003e1.make -nB\u003c/strong\u003e\n当然可以手动获取编译选项，但是这样也是比较复杂的而且十分的低效\n\u003cstrong\u003e2.bear\u003c/strong\u003e\n善于使用工具，君子性非异也，善假于物也。用bear把编译过程包起来就能自动获取编译选项。\u003c/p\u003e\n\u003ch3 id=\"如何在vscode中debug\"\u003e如何在vscode中debug\u003c/h3\u003e\n\u003cp\u003e==官方非GUI界面==\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emake\u003c/span\u003e \u003cspan class=\"n\"\u003eqemu\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003egdb\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e之后系统会在本地启动一个gdb，另起一个终端使用gdb连接。\n\u003cimg alt=\"PixPin_2025-01-04_16-46-16.png600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-01-04_16-46-16.png\"\u003e\n到这就说明gdb启动成功了，但是后面会有一个小小的坑。\u003c/p\u003e\n\u003cp\u003eType \u0026ldquo;apropos word\u0026rdquo; to search for commands related to \u0026ldquo;word\u0026rdquo;. warning: File \u0026ldquo;/home/learn_code/xv6-labs-2024/.gdbinit\u0026rdquo; auto-loading has been declined by your `auto-load safe-path\u0026rsquo; set to \u0026ldquo;$debugdir:$datadir/auto-load:/home/learn_code/xv6-riscv/.gdbinit\u0026rdquo;. To enable execution of this file add add-auto-load-safe-path /home/learn_code/xv6-labs-2024/.gdbinit line to your configuration file \u0026ldquo;/root/.config/gdb/gdbinit\u0026rdquo;. To completely disable this security protection add set auto-load safe-path / line to your configuration file \u0026ldquo;/root/.config/gdb/gdbinit\u0026rdquo;.\u003c/p\u003e","title":"xv6-环境搭建"},{"content":"先随便写几个要点，等整个结束了再详细写。\n动手之前先计划，详细周到考虑 多动手，多试错 多读源代码，多练习debug 英语好好学，英语太重要了。 ","permalink":"https://jialog.top/posts/database/note/cmu15-445%E6%80%BB%E7%BB%93/","summary":"\u003cp\u003e先随便写几个要点，等整个结束了再详细写。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e动手之前先计划，详细周到考虑\u003c/li\u003e\n\u003cli\u003e多动手，多试错\u003c/li\u003e\n\u003cli\u003e多读源代码，多练习debug\u003c/li\u003e\n\u003cli\u003e英语好好学，英语太重要了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"Clip_2024-06-30_15-13-04.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/Clip_2024-06-30_15-13-04.png\"\u003e\u003c/p\u003e","title":"CMU15-445总结"},{"content":"写在前面 在这篇文章中我们先抛开SQL在bustub的中的历程，直接快进到最后开始执行的阶段，这篇文章只关注设计上的细节。\n至于如何理顺这些细节在[[CMU15-445 Project3 - Query Execution]]文章中会有详细的介绍，这里就不再赘述。😃\n架构总览 上图中catalog其实不是特别准确，按照我的理解应该是下面这种情况👇。通过一个table_id双向映射表的名字和实体table。 接下来就按照从上到下的顺序依次介绍各个部分的结构。\nCatalog 下面这个图是是整个catalog关于table的。👇这里引出了TableInfo. Catalog中不仅仅包含table的信息还储存了index的信息。这里引出了IndexInfo,但是后边用的不是很多。 接下来看TableInfo的组成。（TableInfo的定义就在Catalog.h文件中）\nTableInfo name_:就是表的名字 table_: 是一个每个节点都是tablepage的双向链表 oid_: 顾名思义就是表的id Schema_：其实到现在我都没有很弄懂这个是干什么的东西，但是chat给出了答案。 什么是Schema 按照我的理解应该是一个类似于表头的包含各种配置信息的一个抽象集合。现在就看看源码。👇 在bustub中schema的信息似乎没有包含很多，就是对每一个列的数据类型约束进行了记录。以及对所有的列进行一个汇总，方便获取到每一个列。 ==Column==\n实际上每个列的实现实体是Column，在这个实体中包含列名，数据类型，长度等基本信息。 ⚠️值得注意的是column对于varchar单独做了处理🙂,变长数组终究还是不一样啊。 TableHeap 实质上就是配合TablePage里面的信息构成的双向链表，我觉得这个设计真的非常的巧妙。只用了基本的pre_page_id 和next_page_id这两个变量就把双向链表给建立起来而且耦合度非常的低。\nfirst_page_id_: 就是第一个pageid bufferpool：所有的page都需要从bufferpool中去取。 TablePage的结构 ok看到这里有疑问了？ 那么多的信息都存在那里， 这继承的加上初始化的也不够啊。 答案在这里👇 通过偏移量直接在page的剩余空间里去定义各种变量。\n==通过InsertTuple（）函数了解详细结构==\n直接看源代码：\nif (tuple.size_ + 32 \u0026gt; BUSTUB_PAGE_SIZE) { // larger than one page size txn-\u0026gt;SetState(TransactionState::ABORTED); return false; } auto cur_page = static_cast\u0026lt;TablePage *\u0026gt;(buffer_pool_manager_-\u0026gt;FetchPage(first_page_id_)); if (cur_page == nullptr) { txn-\u0026gt;SetState(TransactionState::ABORTED); return false; } 这主要是判断一些前置条件的合法性 为什么要用tuple的大小+32进行比较呢？ 文末给出答案\n在第一页中进行插入，如果没有足够的空间就开一个新页然后插进去 ⚠️需要注意的是，在离开第一页的时候仍然要持有写锁，因为还要写next_page_id变量. 💡跟随代码跳转到TablePage::InserTuple().\nauto TablePage::InsertTuple(const Tuple \u0026amp;tuple, RID * rid, Transaction * txn, LockManager * lock_manager,LogManager * log_manager) -\u0026gt; bool{} 👆是函数的定义。\n开始主要还是判断空间是否够，不够的话直接返回插入失败。 剩下的情况就是空间足够可以进行插入操作然后返回成功。 然后就是对内部的一个变量的改变。主要是数量的改变和指针指向的改变 数量自然是加一，指向空位置的指针也要往回走这个tuple.size()的大小。 💡返回失败之后那自然就要找下一个page，那么就会出现两种情况。\n下一个有page那就直接取然后插入 下一个没page那就new一个page然后初始化 看到这其实整个bustub的架构已经差不多清晰了\nTuples 每一次插入的最小单元tuple到底是什么东西呢？\n这个可以简单的理解为表中的一行。 👇是tuple初始化的过程， 💡 ==RID== 由一个slot_num_和page_id_组成。相当于一个坐标，快速定位在page中的位置。 目前就这么多，剩下的细节等待以后再补充吧。\n复杂算子的结构 task1中基本上所有的算子实现都已经给出了，而且整体结构也都比较简单直白。 接下来主要梳理一下task2的算子结构，🙃。\n不记录一下感觉源码直接从大脑溜走了，一点也记不住。\nAggregation \u0026amp; Join Executors Aggregation 这个算子相对来说就是比较复杂的一个东西了，我现在其实还不是很明白这到底是是个什么东西。 这个算子的一个特别之处就是：Aggregation 是 pipeline breaker。也就是说，Aggregation 算子会打破 iteration model 的规则。原因是，在 Aggregation 的 Init() 函数中，我们就要将所有结果全部计算出来。原因很简单，比如下面这条 sql：\nSELECT t.x, max(t.y) FROM t GROUP BY t.x; SimpleAggregationHashTable,在这个hash表中维护的key和value分别是AggregateKey,AggregaValue. 其实到这里就已经能大致猜到这两个类型是什么东西。但是为了一探究竟我们还是看到底。\n==AggregaKey==\n从这里我们可以得到两个信息，\n类型是std::vector\u0026lt;Value\u0026gt; 看注释的的话这个字段就是group by的字段。 ==AggregaValue==\n得到的信息和上面的类似\n类型是std::vector\u0026lt;Value\u0026gt; 这个字段是 value 则是需要 aggregate 的字段的数组。 InsertCombine()\n上边的CombinAggregateValues()是需要自己进行实现的。但是根据留出来的空大致也能猜出来是根据不同的聚合类型把新插入的数据按照给定的规则进行更新. InsertCombin():如果原来的hash表中没有给定的规则，那就创建一个新的记录。如果有的话就调用上述的函数，讲哈希表中已经存在的按照既定规则出来的值进行更新。 为什么在插入的过程中需要更新呢？ 原因也是非常简单了\u0026mdash;\u0026gt; 加入规则是找一个最大的数，这个时候进来的这个数比表中原来的最大的数大，那自然就需要进行改变。\n所以上述的这个函数实现我想大致思路已经出来了，把每一个新的进来的数据和原来的里面存的数据进行比较，按照规则判定是否需要更新。\n==举个例子==\nSELECT min(t.z), max(t.z), sum(t.z) , count(t.z) FROM t GROUP BY t.x, t.y; 在这个上述过程中函数中每个变量对应的是什么？\nAggregateKey 上文提到是group的字段 在这个sql中对应的自然就是「 t.x ，t.y」 AggregateValue 对应的是四个类型 「t.z t.z t.z t.z 」 AggregationType 对应的规则为 「min ，max ，sum ，count」\n通过相对位置来确定对应的规则和值。\nNestedLoopJoin 在chatGPT中对这个循环嵌套给出了如下的解释。但是想实现好确并不容易。\nAndy 在 Lecture 里也详细地量化地对比了各种 Join 的 costs，有兴趣可以看看。\nrisinglight/src/executor/nested_loop_join.rs at main · risinglightdb/risinglight · GitHub\n参照上述的join实现比较的优雅。这也是Bustub的作者参与的一个开源项目，参考原作者的实现我想会有意想不到的奇效。\n==思路整理==\n第一版\n按照课上讲的思路，就是两个循环直接进行嵌套发现有一样的就直接返回\nwhile(leftchild-\u0026gt;next(lefttuple)){ for(auto rightchild : righttuple){ if(leftchild==rightchild){ *tuple = ...; return true; } } } 但是按照上述的思路我们会发现一个很致命的问题，如果右边的tuple里面有重复的值与左面的值匹配的话上述代码只会匹配第一个相等的tuple然后就返回了。\n👇举个例子\nt1.x | t2.x ----- 1 | 0 2 | 1 \u0026lt;--- 3 | 1 4 | 2 按照正确的应该t1.x的1和 t2.x 中的两个1进行匹配 但是上述代码的逻辑只会匹配到箭头指的地方然后就返回了。\n+32去比较的原因是父类page和tablepage的head一共需要预留32b的位置。\n","permalink":"https://jialog.top/posts/database/note/bustub%E6%89%A7%E8%A1%8C%E5%99%A8%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"写在前面\"\u003e写在前面\u003c/h2\u003e\n\u003cp\u003e在这篇文章中我们先抛开SQL在bustub的中的历程，直接快进到最后开始执行的阶段，这篇文章只关注设计上的细节。\u003c/p\u003e\n\u003cp\u003e至于如何理顺这些细节在[[CMU15-445 Project3 - Query Execution]]文章中会有详细的介绍，这里就不再赘述。😃\u003c/p\u003e\n\u003ch2 id=\"架构总览\"\u003e架构总览\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221212132.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图中catalog其实不是特别准确，按照我的理解应该是下面这种情况👇。通过一个table_id双向映射表的名字和实体table。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221212842.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接下来就按照从上到下的顺序依次介绍各个部分的结构。\u003c/p\u003e\n\u003ch2 id=\"catalog\"\u003eCatalog\u003c/h2\u003e\n\u003cp\u003e下面这个图是是整个catalog关于table的。👇这里引出了\u003ccode\u003eTableInfo\u003c/code\u003e.\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221221311.png\"\u003e\u003c/p\u003e\n\u003cp\u003eCatalog中不仅仅包含table的信息还储存了index的信息。这里引出了\u003ccode\u003eIndexInfo\u003c/code\u003e,但是后边用的不是很多。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221222700.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接下来看\u003ccode\u003eTableInfo\u003c/code\u003e的组成。（TableInfo的定义就在Catalog.h文件中）\u003c/p\u003e\n\u003ch2 id=\"tableinfo\"\u003eTableInfo\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"主要成员变量|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221223744.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ename_:就是表的名字\u003c/li\u003e\n\u003cli\u003etable_: 是一个每个节点都是tablepage的双向链表\u003c/li\u003e\n\u003cli\u003eoid_: 顾名思义就是表的id\u003c/li\u003e\n\u003cli\u003eSchema_：其实到现在我都没有很弄懂这个是干什么的东西，但是chat给出了答案。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"什么是schema\"\u003e什么是Schema\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221224249.png\"\u003e\n按照我的理解应该是一个类似于表头的包含各种配置信息的一个抽象集合。现在就看看源码。👇\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221225429.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在bustub中schema的信息似乎没有包含很多，就是对每一个列的数据类型约束进行了记录。以及对所有的列进行一个汇总，方便获取到每一个列。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221225647.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e==Column==\u003c/p\u003e\n\u003cp\u003e实际上每个列的实现实体是\u003ccode\u003eColumn\u003c/code\u003e，在这个实体中包含\u003cstrong\u003e列名，数据类型，长度\u003c/strong\u003e等基本信息。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221230318.png\"\u003e\u003c/p\u003e\n\u003cp\u003e⚠️值得注意的是column对于\u003ccode\u003evarchar\u003c/code\u003e单独做了处理🙂,变长数组终究还是不一样啊。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221231559.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"tableheap\"\u003eTableHeap\u003c/h2\u003e\n\u003cp\u003e实质上就是配合\u003ccode\u003eTablePage\u003c/code\u003e里面的信息构成的双向链表，我觉得这个设计真的非常的巧妙。只用了基本的\u003ccode\u003epre_page_id\u003c/code\u003e 和\u003ccode\u003enext_page_id\u003c/code\u003e这两个变量就把双向链表给建立起来而且耦合度非常的低。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221233636.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efirst_page_id_: 就是第一个pageid\u003c/li\u003e\n\u003cli\u003ebufferpool：所有的page都需要从bufferpool中去取。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tablepage的结构\"\u003eTablePage的结构\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240222001937.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240222001143.png\"\u003e\u003c/p\u003e\n\u003cp\u003eok看到这里有疑问了？ 那么多的信息都存在那里， 这继承的加上初始化的也不够啊。\n答案在这里👇\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240222001417.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过\u003ccode\u003e偏移量\u003c/code\u003e直接在page的剩余空间里去定义各种变量。\u003c/p\u003e\n\u003cp\u003e==通过InsertTuple（）函数了解详细结构==\u003c/p\u003e\n\u003cp\u003e直接看源代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etuple\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize_\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eBUSTUB_PAGE_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c1\"\u003e// larger than one page size\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003etxn\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetState\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTransactionState\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eABORTED\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003ecur_page\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTablePage\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuffer_pool_manager_\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eFetchPage\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efirst_page_id_\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecur_page\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003etxn\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetState\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTransactionState\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eABORTED\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e这主要是判断一些前置条件的合法性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003e为什么要用tuple的大小+32进行比较呢？\u003c/em\u003e 文末给出答案\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|800\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240222002633.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在第一页中进行插入，如果没有足够的空间就开一个新页然后插进去\u003c/li\u003e\n\u003cli\u003e⚠️需要注意的是，在离开第一页的时候\u003cstrong\u003e仍然要持有写锁\u003c/strong\u003e，因为还要写\u003ccode\u003enext_page_id\u003c/code\u003e变量.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e💡跟随代码跳转到\u003ccode\u003eTablePage::InserTuple()\u003c/code\u003e.\u003c/p\u003e","title":"Bustub架构简单分析"},{"content":"事务 ==Transaction==\n在英文中事务用transaction表示，一般约定俗成的缩写为txn，所以在数据库的源代码中看到txn的话多半就是事务。\n==事务诞生的背景==\n我们假设一个银行的场景，转账这一操作在外界看来是单一的操作，但是在数据库内部涉及到很多的操作，假如转账操作发生了失败，那么数据的不一致是不能被接受的。所以这一连串的操作可以被归为逻辑上的一个操作集。要么整体都成功要么都失败。\n事务的概念 在chatgpt上问事务的概念他会这样子进行回答。 这也正是事务的关键。 我们回归课本，看课本上给出的定义 事务的隔离性级别 我个人觉得对于隔离性的的理解是非常重要的，在后续的算子的实现当中几乎都要考虑事务的隔离等级，根据不同的隔离等级去进行不同的操作。（我个人现在比较迷茫的是怎么能比较周全的考虑不同隔离等级所带来的影响。：）。看来是时候找个大佬请教一下了。🙃\n","permalink":"https://jialog.top/posts/database/note/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","summary":"\u003ch1 id=\"事务\"\u003e事务\u003c/h1\u003e\n\u003cp\u003e==Transaction==\u003c/p\u003e\n\u003cp\u003e在英文中事务用transaction表示，一般约定俗成的缩写为\u003ccode\u003etxn\u003c/code\u003e，所以在数据库的源代码中看到\u003ccode\u003etxn\u003c/code\u003e的话多半就是事务。\u003c/p\u003e\n\u003cp\u003e==事务诞生的背景==\u003c/p\u003e\n\u003cp\u003e我们假设一个银行的场景，\u003cstrong\u003e转账\u003c/strong\u003e这一操作在外界看来是单一的操作，但是在数据库内部涉及到很多的操作，假如转账操作发生了失败，那么数据的不一致是不能被接受的。所以这一连串的操作可以被归为逻辑上的一个操作集。要么整体都成功要么都失败。\u003c/p\u003e\n\u003ch2 id=\"事务的概念\"\u003e事务的概念\u003c/h2\u003e\n\u003cp\u003e在chatgpt上问事务的概念他会这样子进行回答。\n这也正是事务的关键。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240220222726.png\"\u003e\n我们回归课本，看课本上给出的定义\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240220231837.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"事务的隔离性级别\"\u003e事务的隔离性级别\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221012712.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我个人觉得对于隔离性的的理解是非常重要的，在后续的算子的实现当中几乎都要考虑事务的隔离等级，根据不同的\u003cstrong\u003e隔离等级\u003c/strong\u003e去进行不同的操作。（我个人现在比较迷茫的是怎么能比较周全的考虑不同隔离等级所带来的影响。：）。看来是时候找个大佬请教一下了。🙃\u003c/p\u003e","title":"数据库事务"},{"content":" Join Operation， 连表 在查询过程中经常会涉及到连表的操作。那么为什么总是需要连表呢？\n==为什么需要连表？==\n在存储的时候为了避免数据的冗杂，将表进行规范化，导致表的割裂。 在查询的时候需要获取完整的信息，所以将表进行重新的组装。 连表的算法 Fetching Title#i6kq\n","permalink":"https://jialog.top/posts/database/note/%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/","summary":"\u003chr\u003e\n\u003ch2 id=\"join-operation-连表\"\u003eJoin Operation， 连表\u003c/h2\u003e\n\u003cp\u003e在查询过程中经常会涉及到连表的操作。那么为什么总是需要连表呢？\u003c/p\u003e\n\u003cp\u003e==为什么需要连表？==\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240209151410.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在存储的时候为了避免数据的冗杂，将表进行规范化，导致表的割裂。\u003c/li\u003e\n\u003cli\u003e在查询的时候需要获取完整的信息，所以将表进行重新的组装。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"连表的算法\"\u003e连表的算法\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/show.mp4\"\u003eFetching Title#i6kq\u003c/a\u003e\u003c/p\u003e","title":"查询的处理和优化"},{"content":"做这个p3首先需要明晰整个bustub的架构[[Bustub执行器架构简单分析]],在这个文章中进行了很详细的分析。 ","permalink":"https://jialog.top/posts/database/project/cmu15-445-project3---query-execution/","summary":"\u003cp\u003e做这个p3首先需要明晰整个bustub的架构[[Bustub执行器架构简单分析]],在这个文章中进行了很详细的分析。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240221215146.png\"\u003e\u003c/p\u003e","title":"CMU15-445-Project #3 - Project3 - Query Execution"},{"content":"CHECKPOINT-2 Task #3 - Index Iterator 简单来说就是实现一个迭代器\n将所有的叶子节点视为一个链表，要求实现给出的函数。在当前的迭代器中保存所在的pageId和当前的起始位置，然后通过leafpage中的next_page_id来获取下一个叶子节点。 总体上来说难度不是很大，没有什么好说的，就是还是注意要加锁，其中的某一个函数在实现的时候需要考虑跨页的情况，这时候就要考虑加锁和去锁的情况了。\nTask #4 - Concurrent Index 这就是要完实现一个多线程的b+树，加锁的实现方式和原理在[[B+ Tree Index#b+ tree latches]]中有比较详细的介绍，这里我简单的解释一下。\n这是整个项目的重点也是难点，考察对b+树整个结构和每个操作涉及到的点，当然可以像之前的项目一样一把大锁报平安，但是对于b+树来说这样会使的性能约等于单线程，每次都需要从根节点进入整个树，但是一把大锁就意味着每次整个树中都只能存在一个线程在操作。。。\n所以我们需要更细粒度的锁，于是螃蟹锁🦀应运而生。 ：）rust的吉祥物也是个螃蟹吧。。\n==螃蟹锁==\n因为其加锁和解锁的过程以及逻辑特别像螃蟹的行走的方式，因此而得名螃蟹锁。\n读模式\n在读模式的时候最为形象，当获取到父节点的读锁之后，尝试着获取目标子节点的读锁，当获取到锁之后立马释放父节点的锁 在上图中，一个线程获取A页的锁之后会尝试着获取目标子节点B的锁，当获取B的锁之后就会释放A的锁。如此循环往复，就像螃蟹在走。\n写模式\n写模式的时候只是锁释放的条件不一样，读模式的时候当获取的下一个页的锁的时候就可以立马释放当前页的锁，但是写模式涉及到插入和删除，可能整个路径上的页都会受影响。 如上图所示，当获取到B页的锁的时候不能释放A页的锁，因为B有可能会发生合并，于是继续向下获取锁，获取到C页的锁之后发现C页是处于安全状态的。所以可以释放C页之上的所有锁。⚠️注意：并不包括C本身。\n安全状态\n安全状态的这个概念只存在于写模式的时候。需要注意的是：在删除和插入的时候页处于安全状态的条件并不一样。\n在插入的时候：该页不是满的\u0026mdash;\u0026ndash;》就算发生分裂的情况，到此页也就结束了。 在删除的时候：大于半数\u0026mdash;\u0026mdash;\u0026mdash;》就算删除之后发生合并或者重新分配到此页就结束了。 螃蟹锁的优势在哪里？\n⚠️这里的优势是相较于一把大锁而言。 虽然B+树可以做的很高很大，但是无论如何都只有一个入口。如果每次都是一把大锁，那不管什么操作都会先获取根节点并且锁住，那直接就编程单线程的了。\n所以整个的瓶颈就是根节点上锁的时间太长了。影响了并发。所以螃蟹锁的优势就在于：\n能够显著的减少根结点上锁的时间，让更多的线程进入B+树进行操作 更优的螃蟹锁执行策略\n当前释放的策略仍然拥有很大的优化空间。在原来的策略上写模式的时候会对根节点上写锁，知道找到一个安全节点之后才会释放，这就占用了很长时间，导致效率降低。这种不分青红皂白的直接给各个节点上写锁的行为称之为悲观锁。顾名思义，悲观锁表示这种策略对多线程的执行非常的悲观，觉得每个页都会被修改，必须都上锁才安心。但是事实上在实际的应用过程中触发分裂或者合并并不是很频繁。\n所以就诞生了一种更优的加锁策略乐观锁，在写模式的时候就大胆的假设从根节点到最后的叶子节点都是安全的，给路径的页都上读锁，最后的叶子节点才上写锁。如果在这个过程中发现了某个节点跟假设的不一样，不是安全的，那么之前的所有锁都释放，再重新按照悲观锁的方式进行操作。\n这样做的好处是，在相较于悲观锁乐观锁在一定程度上能改善根节点总是上写锁导致并发时读取效率的降低。\n但是我本人还没有实现乐观锁，修改FindLeafPage()或者添加FindLeafPageHelper()应该都是可以的。\n具体实现 ==GetValue（）==\n如上如所示，当获取到下一个读锁的时候就释放父节点的读锁，然后接着循环这样的操作 这样子像螃蟹走路的方式，也是这种加锁策略的由来。 ==Insert（）==\n还有一个图我懒得画了，page4也是不安全的，所以page2、3、4.在这里都不能释放。 找到一个安全的节点之后如何安全有便捷的释放所有父节点链的锁呢？ ==Remove（）==\n移除和上图大同小异啦，就是判断安全的条件不一样啦。注意一下就好了\nTransaction、事务\n这里就用到了我在checkpoint1中提到的这个东西[[CMU15-445 Project2-B+ Tree Index Checkpoint 1#^d53eec|对Transaction的详细介绍]],可以翻看前文。 它可以跟踪记录某个线程上的锁，并且是按照顺序的。从上到下。便于进行统筹操作。\n由于越往上page越密集，竞争越激烈，在释放锁的时候可以优先释放处于顶部的锁，也算是一个小优化🤣。\nSummary 整个checkpoint2想较于checkpoint1来说我觉得需要注意的事情更多。特别是对根节点的加锁时机的把握，很重要的。难度我觉得是有提升的。\n写完这个让我体会最深的是，代码写完整个工作完成百分之20，跑起来并且过本地测试勉强算完成一半，线上测试是真难啊啊啊，每次卡玩都回来一点一点看log👀，眼瞪的比黑猫警长还大。\n最后附上通过截图。 rank也比较靠后，等实现乐观锁之后希望不会负优化。\n现在不用担心了，用了一下午乐观锁总是出问题，线上测试a不了。也算是负优化失败了。🤣\n","permalink":"https://jialog.top/posts/database/project/cmu15-445-project2-b+-tree-index-checkpoint-2/","summary":"\u003ch2 id=\"checkpoint-2\"\u003eCHECKPOINT-2\u003c/h2\u003e\n\u003ch3 id=\"task-3---index-iterator\"\u003eTask #3 - Index Iterator\u003c/h3\u003e\n\u003cp\u003e简单来说就是实现一个迭代器\u003c/p\u003e\n\u003cp\u003e将所有的叶子节点视为一个链表，要求实现给出的函数。在当前的迭代器中保存所在的pageId和当前的起始位置，然后通过leafpage中的next_page_id来获取下一个叶子节点。\n总体上来说难度不是很大，没有什么好说的，就是还是注意要加锁，其中的某一个函数在实现的时候需要考虑跨页的情况，这时候就要考虑加锁和去锁的情况了。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"task-4---concurrent-index\"\u003eTask #4 - Concurrent Index\u003c/h3\u003e\n\u003cp\u003e这就是要完实现一个多线程的b+树，加锁的实现方式和原理在[[B+ Tree Index#b+ tree latches]]中有比较详细的介绍，这里我简单的解释一下。\u003c/p\u003e\n\u003cp\u003e这是整个项目的重点也是难点，考察对b+树整个结构和每个操作涉及到的点，当然可以像之前的项目一样一把大锁报平安，但是对于b+树来说这样会使的性能约等于单线程，每次都需要从根节点进入整个树，但是一把大锁就意味着每次整个树中都只能存在一个线程在操作。。。\u003c/p\u003e\n\u003cp\u003e所以我们需要\u003cstrong\u003e更细粒度\u003c/strong\u003e的锁，于是螃蟹锁🦀应运而生。 ：）rust的吉祥物也是个螃蟹吧。。\u003c/p\u003e\n\u003cp\u003e==螃蟹锁==\u003c/p\u003e\n\u003cp\u003e因为其加锁和解锁的过程以及逻辑特别像螃蟹的行走的方式，因此而得名\u003cstrong\u003e螃蟹锁\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e读模式\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e在\u003cstrong\u003e读模式\u003c/strong\u003e的时候最为形象，当获取到父节点的读锁之后，尝试着获取目标子节点的读锁，当获取到锁之后立马释放父节点的锁\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207192232.png\"\u003e\n在上图中，一个线程获取A页的锁之后会尝试着获取目标子节点B的锁，当获取B的锁之后就会释放A的锁。如此循环往复，就像螃蟹在走。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e写模式\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e写模式的时候只是锁释放的条件不一样，读模式的时候当获取的下一个页的锁的时候就可以立马释放当前页的锁，但是写模式涉及到\u003cstrong\u003e插入\u003c/strong\u003e和\u003cstrong\u003e删除\u003c/strong\u003e，可能整个路径上的页都会受影响。\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207192622.png\"\u003e\n如上图所示，当获取到B页的锁的时候不能释放A页的锁，因为B有可能会发生合并，于是继续向下获取锁，获取到C页的锁之后发现C页是处于\u003cstrong\u003e安全状态\u003c/strong\u003e的。所以可以释放C页之上的所有锁。⚠️注意：并不包括C本身。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e安全状态\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e安全状态的这个概念只存在于\u003cstrong\u003e写模式\u003c/strong\u003e的时候。需要注意的是：在\u003cstrong\u003e删除\u003c/strong\u003e和\u003cstrong\u003e插入\u003c/strong\u003e的时候页处于安全状态的\u003cstrong\u003e条件\u003c/strong\u003e并不一样。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207193015.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在插入的时候：该页不是满的\u0026mdash;\u0026ndash;》就算发生分裂的情况，到此页也就结束了。\u003c/li\u003e\n\u003cli\u003e在删除的时候：大于半数\u0026mdash;\u0026mdash;\u0026mdash;》就算删除之后发生合并或者重新分配到此页就结束了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e螃蟹锁的优势在哪里？\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e⚠️这里的优势是相较于一把大锁而言。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e虽然B+树可以做的很高很大，但是无论如何都只有一个入口。如果每次都是一把大锁，那不管什么操作都会先获取根节点并且锁住，那直接就编程单线程的了。\u003c/p\u003e\n\u003cp\u003e所以整个的\u003cstrong\u003e瓶颈\u003c/strong\u003e就是根节点上锁的时间太长了。影响了并发。所以螃蟹锁的优势就在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e能够显著的减少根结点上锁的时间，让更多的线程进入B+树进行操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e更优的螃蟹锁执行策略\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当前释放的策略仍然拥有很大的优化空间。在原来的策略上写模式的时候会对根节点上写锁，知道找到一个安全节点之后才会释放，这就占用了很长时间，导致效率降低。这种不分青红皂白的直接给各个节点上写锁的行为称之为\u003cstrong\u003e悲观锁\u003c/strong\u003e。顾名思义，悲观锁表示这种策略对多线程的执行非常的悲观，觉得每个页都会被修改，必须都上锁才安心。但是事实上在实际的应用过程中触发分裂或者合并并不是很频繁。\u003c/p\u003e\n\u003cp\u003e所以就诞生了一种更优的加锁策略\u003cstrong\u003e乐观锁\u003c/strong\u003e，在写模式的时候就大胆的假设从根节点到最后的叶子节点都是安全的，给路径的页都上读锁，最后的叶子节点才上写锁。如果在这个过程中发现了某个节点跟假设的不一样，不是安全的，那么之前的所有锁都释放，再重新按照\u003cstrong\u003e悲观锁\u003c/strong\u003e的方式进行操作。\u003c/p\u003e\n\u003cp\u003e这样做的好处是，在相较于悲观锁乐观锁在一定程度上能改善根节点总是上写锁导致并发时读取效率的降低。\u003c/p\u003e\n\u003cp\u003e但是我本人还没有实现乐观锁，修改\u003ccode\u003eFindLeafPage()\u003c/code\u003e或者添加\u003ccode\u003eFindLeafPageHelper()\u003c/code\u003e应该都是可以的。\u003c/p\u003e\n\u003chr\u003e\n\u003ch4 id=\"具体实现\"\u003e具体实现\u003c/h4\u003e\n\u003cp\u003e==GetValue（）==\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207222907.png\"\u003e\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207223113.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如上如所示，当获取到下一个读锁的时候就释放父节点的读锁，然后接着循环这样的操作\u003c/li\u003e\n\u003cli\u003e这样子像螃蟹走路的方式，也是这种加锁策略的由来。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e==Insert（）==\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207225033.png\"\u003e\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207225237.png\"\u003e\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207225451.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e还有一个图我懒得画了，page4也是不安全的，所以page2、3、4.在这里都不能释放。\u003c/li\u003e\n\u003cli\u003e找到一个安全的节点之后如何安全有便捷的释放所有父节点链的锁呢？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e==Remove（）==\u003c/p\u003e\n\u003cp\u003e移除和上图大同小异啦，就是判断安全的条件不一样啦。注意一下就好了\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTransaction、事务\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这里就用到了我在checkpoint1中提到的这个东西[[CMU15-445 Project2-B+ Tree Index Checkpoint 1#^d53eec|对Transaction的详细介绍]],可以翻看前文。\n它可以跟踪记录某个线程上的锁，并且是按照顺序的。从上到下。便于进行统筹操作。\u003c/p\u003e\n\u003cp\u003e由于越往上page越密集，竞争越激烈，在释放锁的时候可以优先释放处于顶部的锁，也算是一个小优化🤣。\u003c/p\u003e\n\u003ch3 id=\"summary\"\u003eSummary\u003c/h3\u003e\n\u003cp\u003e整个checkpoint2想较于checkpoint1来说我觉得需要注意的事情更多。特别是对根节点的加锁时机的把握，很重要的。难度我觉得是有提升的。\u003c/p\u003e\n\u003cp\u003e写完这个让我体会最深的是，代码写完整个工作完成百分之20，跑起来并且过本地测试勉强算完成一半，线上测试是真难啊啊啊，每次卡玩都回来一点一点看log👀，眼瞪的比黑猫警长还大。\u003c/p\u003e\n\u003cp\u003e最后附上通过截图。\n\u003cimg alt=\"image.png|350\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207232212.png\"\u003e\n\u003cimg alt=\"image.png|775\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240207232250.png\"\u003e\u003c/p\u003e","title":"CMU15-445-Project #2 - B+ Tree Index Checkpoint 2"},{"content":"一些工具 BusTub B+Tree PrinterCMU官方在线的B+树的生成工具。我主要用来细节实现的时候进行参考。 JavaScript B+ TreeB+树插入和删除的动态演示。 Graphviz Online可视化自己的树。在debug的时候会用到。将生成的dot文件转换成svg图片。 Log In | Gradescope在线评测网站,邀请码：PXWVR5， Project #2 - B+Tree | CMU 15-445/645 :: Intro to Database Systems (Fall 2022)最重要的当然还是课程网站了 课程的视频，还有对应的教材还是推荐看一下的上面有很多实现细节的。非常值得参考。 如何Debug自己的🌳 大致上可以分为两种方式\n可视化的用自带的printer将树生成dot文件然后复制到上面的可视化网站。 由于本项目采用的是cmake构建的，所以可以很方便的在测试文件中打上断点。进行调试。 ==可视化调试==\n在终端中执行以下命令，构建和执行printer。\n➜ build git:(main) make b_plus_tree_printer -j2 // 构建printer ➜ build git:(main) ./bin/b_plus_tree_printer // 执行printer 执行完之后就会有以下提示：\n按照这个提示就可以生成dot文件，然后复制到上述的网站进行可视化。（当你看到自己的树呈现出来的时候还是非常有成就感的😁）\n==非可视化==\n可以很方便的直接打断点，然后在vscode中的cmake插件中选择调试进行debug。\n官方还提供了一种大打log的方式进行debug，我是不太习惯这种方式所以没有进行很深入的研究。感兴趣的可以自己进行了解😗。\n两种debug的方式是相辅相成的，在你过不了本地样例的时候好好的用非可视化的方式进行debug，线上样例过不了大部分原因是细节处理上出问题了。用可视化的方式会更加的直观。\n请不要公开代码，尊重Andy劳动成果\n概览 Project2是实现B+树索引，整个project大致被分为了两个部分\ncheckpoint1：实现一个单线程的b+树。 checkpoint2：实现一个多线程的b+树。 实验代码中给出的自由发挥的空间非常的大，只给出了Getvalue(),Insert(),Remove()这三个函数的接口，剩下的所有的实现都非常的自由，整个实验实现的过程就像一个黑盒一样，只在乎输入和输出。\n本实验需要完成b+ index部分，b+树中的页（page）都需要从上一个实验中实现的buffer pool中取。\nCheckpoint-1 Task #1 - B+Tree Pages 需要完成以下三个page，主要都是一些getter和setter的函数，重在理解各部分的组成。\nB+Tree Parent Page B+Tree Internal Page B+Tree Leaf Page 其中parentPage是internal page和leaf page的父类。我更倾向于把这几个page类型理解为 从buffer pool中取回来的Page的不同解释形式。Page还是那个Page。主要就是在于你如何去解释它的组成部分。\n==Page的组成==\n首先回顾一下在P1中就已经接触到的Page。这个Page我理解为数据在disk上的存储单位。相当于一个计量概念。\n可以看出这个data_数组的大小为4096B即4KB。这个大小是定义的常量BUSTUB_PAGE_SIZE决定的。\n本项目的所有的数据都是在data_中的。\u0026mdash;\u0026ndash;我理解的就是对data数组中的数据解释方式不同。\n==BPlusTreePage==\n这是internal page和leaf page的父类b_plus_tree_page。\nIndexPageType page_type_; // leaf or internal. 4 Byte lsn_t lsn_ // temporarily unused. 4 Byte int size_; // tree page data size(not in byte, in count). 4 Byte int max_size_; // tree page data max size(not in byte, in count). 4 Byte page_id_t parent_page_id_; // 4 Byte page_id_t page_id_; // 4 Byte // 24 Byte in total 以上部分组成了两种节点的公共部分，共占据24B，还剩下4KB-24B的空间，但是如何使用这剩下的空间呢？ 可以从下面的这个flexible数组找到答案。这个大佬解释的比较的详细，我也是在这看到的。做个数据库：2022 CMU15-445 Project2 B+Tree Index - 知乎\n众所周知，数据在数组中的排列是连续的，可以通过下标一直向下进行访问，就是通过利用这个特性使用头指针加上偏移量就到准确的找到我们想要的那个数据。\n因此我认为这个array_数组相当于提供了一个使用剩下空间的一个入口，有个这个门把手就可以轻松的使用剩下的空间。 大致可以认为数据就是以上的这种形式。每一个小方格都是一个kv对。\n今天我在网上冲浪的时候发现了更加详细的关于柔性数组的信息。 截图自C语言结构体里的成员数组和指针 | 酷 壳 - CoolShell。 同时这篇文章也贴出了文章出处Zero Length (Using the GNU Compiler Collection (GCC))。\n现在细细想来这篇博客我很早其实就看到过，但是在当时我总觉得这些都是一些语法糖罢了，没想到自己错失了很多学习的机会。🤤\n==Internalpage==\n上图中红色的就是internalpage。 我们发现第一个key是空着的，但是value指向了小于value（1）的page。其实internal的value存放的是pageid。 所以internalpage的第一个key要置空处理，其实最后一个置空也可以了，只要能自洽就可以了。\n需要注意的是：这里只存放孩子节点的pageId，找到这个id之后取buffer pool里取 ==LeafPage==\n基本组成和这个internalpage是一样的，多了一个next_page_id. 这个next_page_id用与指向相邻的叶子节点，从上图中绿色叶子节点的指针就能看出来。 这个的主要作用就是能够进行遍历。\n需要说明的一点是：在叶子节点中key是索引，value是recordId，这种形式也就是二级索引 在数据库中需要拿到这个recodeId之后返回表中进行查询。大大加快查询的速度。\n我觉得二级索引有以下几个优势：\n更新的代价很低：因为value都只是一些id所以占得空间很小，处理起来开销自然就小了。 一张表能够组织多个索引：更换不同的key就能组织起来一个索引。 Task1的内容很简单，基本就上述这些，主要是弄清楚page的组成，和框架的构建。被折磨了这么多天的我真心建议多用提供的工具画一些树先不要着急动手，想清楚每个部分的组成和作用再下手也不迟，正所谓磨刀不误砍柴工。\n==补充一点==\n聚簇索引和非聚簇索引（二级索引） 一言以蔽及：聚簇索引的value就是你想要找的数据或者是数据所在的页本身，非聚簇索引存放的相当于是你想要的数据所在位置的快速指针帮助你快速定位。\nTask #2 - B+Tree Data Structure task2是checkpoint1的重头戏，非常的有意思。 有几个需要注意的点：\n要求此b+树的索引是唯一的，不支持重复的插入。 UpdateRootPageId在root_page_id发生改变的时候需要调用已经实现好的这个函数，保证树的持久化。 在实现的时候一定多多考虑实现的细节，比如每种节点的最大最小值，插入后的键/值对的数量等于叶节点的max_size，插入前的子节点的数量等于内部节点的max_size。 下面按照函数的顺序进行介绍。 在介绍函数之前我想说明一下Transaction这个类的作用。顾名思义，这个Transaction被翻译为事务。在这篇文章中对这个事务有着详细的介绍。[[查询的处理和优化]]。 在这个类中实现了很多函数，可以把需要处理的page放在实务中等结束了进行统一的处理。因为在函数中涉及到很多的fetch和unpin，而且函数还有递归嵌套，处理起来是非常的麻烦，所以我建议直接尝试使用transaction，反正后面也要用。 ^d53eec\nGetValue（） ==GetValue（）==\n写到这里的时候理应对b+树的结构非常的了解，其实也就是两种节点，一种是internal，一种是leaf，从root节点开始寻找每一个节点中最后一个\u0026lt;=输入key的值。然后找到key所在的leaf节点，从前向后遍历，找到想要的值。下面是一个模拟示意图👇。 其实无论我们是查找，插入，还是删除，首先都必须找到key所在的leaf节点。由此可以将上面这个寻找key所在的leaf节点的过程封装出一个使用频率极高而且非常重要的函数：FindLeafPage()。我们从书上给出的伪代码和上述模拟过程对照分析。\n虽然说我们要找的是最后一个\u0026lt;=输入key的值，但是在具体的伪代码实现中确实寻找第一个\u0026gt;=输入key的值，并进行分类讨论。\nauto next_page = buffer_pool_manager_-\u0026gt;FetchPage(curr_internal-\u0026gt;LookUp(key, comparator_)); auto target=std::lower_bound(array_+1,array_+GetSize(),key,[\u0026amp;keyComparator](auto const\u0026amp;pair,auto k){return keyComparator(pair.first,k)\u0026lt;0; }); if (target==array_+GetSize()) { return ValueAt(GetSize()-1); // 输入的key比所有的值都大，返回最后一个 } if (keyComparator(target-\u0026gt;first,key)==0) { return target-\u0026gt;second; //找到的target的key和输入的key相同就返回target的value } return std::prev(target)-\u0026gt;second; // 找到了第一个大于key的target，返回前一个的value。 LookUp返回的就是page_id,前面我们也提到过，internal节点的value就是page_id. 这里用到了lower_bound（）函数，比自己实现二分查找会方便一些。\n但是这个lower_bound函数传入了keycompareter（）的比较方法，进行了回调函数的改造，使用类定义的比较规则。不是简单的比大小。\n现在找到了key所在的page我们该如何使用这个page呢？\nauto leaf_page = reinterpret_cast\u0026lt;LeafPage *\u0026gt;(page-\u0026gt;GetData()); 通过reinterpret_cast将page解释为LeafPage类型。来供我们进行使用。需要注意的是这种方式非常的不安全，只是将同样的数据进行了不同的解释。只有在我们非常清楚两者之间的关系的时候使用才不容易出错。\n找到LeafPage后同样使用上述改造过后的的lower_bound()函数进行查找key😀。\n==记得UnpinPage==\n在使用完page之后一定记得unpin不然的话高强度使用过后内存会不足。 我的比较建议还是之前提到的transaction，进行统筹处理，少死点脑细胞。\nInsert（） 相较于上一个函数而言，insert（）的逻辑就相对而言要复杂一些了。\n==Insert（）== 插入一个kv对由少到多的情况一个一个进行梳理\n刚开始树是空的：需要新建一个根节点。 有空间能够直接插入 插入之后pageSize=leafMaxSize，需要进行分裂，分裂之后将新的page插入到父节点中。 有重复的插入，直接返回。 现在再看伪代码大概的情况也是这几种。 对照代码再分析一下：\nINDEX_TEMPLATE_ARGUMENTS auto BPLUSTREE_TYPE::Insert(const KeyType \u0026amp;key, const ValueType \u0026amp;value, Transaction *transaction) -\u0026gt; bool { if (IsEmpty()) { StartNewTree(key, value); // 这个对应空树的情况， return true; } return InsertIntoLeaf(key, value, transaction); // 剩下的所有情况都在这处理 } 书上给的伪代码是插入之前与(leaf_max_size-1)进行比较，我在处理的时候是插入之后与leaf_max_size进行比较。\n⚠️ 这里需要注意的是LeafPage和InternalPage的分裂条件并不一样，也就是说leafpage中最多有(leaf_max_size-1)个kv对，而internal中可以有internal_max_size个kv对。 两个的max_size都是5，但是最多的kv对确是不一样的。\n==InsertIntoLeaf()==\nauto leaf_page = reinterpret_cast\u0026lt;LeafPage *\u0026gt;(page-\u0026gt;GetData()); int pre_size = leaf_page-\u0026gt;GetSize(); int curr_size = leaf_page-\u0026gt;Insert(key, valueType, comparator_); if (pre_size == curr_size) { // 这是有重复的节点直接返回 Unpin(transaction, I); return false; } if (curr_size == leaf_max_size_) { // 插入之后等于叶子节点的最大值那么就进行愉快的分裂吧。 page_id_t new_page_leaf_id; auto new_leaf_node_page = buffer_pool_manager_-NewPage(\u0026amp;new_page_leaf_id); auto new_leaf = reinterpret_cast\u0026lt;LeafPage *\u0026gt;(new_leaf_node_page-\u0026gt;GetData()); new_leaf-\u0026gt;Init(new_page_leaf_id, INVALID_PAGE_ID, leaf_max_size_); leaf_page-\u0026gt;Split(new_leaf_node_page); InsertIntoParent(page, new_leaf-\u0026gt;KeyAt(0), new_leaf_node_page, transaction); } 到这里所有的插入的情况就已经考虑完全了，但是分裂之后需要将新分裂的页插入到父节点中，插入到父节点中之后又涉及到父节点分裂的问题，这就是一个递归嵌套了\n==InsertIntoParent()==\n仔细看伪代码的写法，基本是按照伪代码一步步写成的。\nINDEX_TEMPLATE_ARGUMENTS auto BPLUSTREE_TYPE::InsertIntoParent(Page *old_leaf, const KeyType \u0026amp;key, Page *new_leaf, Transaction *transaction)-\u0026gt; void{ // 如果原页是根节点，那么新建一个根节点，将新旧节点插入到新的根节点中，并更新节点 if（old_leaf-\u0026gt;pageID==root_page_id）{ //新建一个节点作为根节点，把两个都插入之后更新各自的指针 ps.进到这个函数的时候说明根节点已经满了，所以直接创一个新的就行了。 } if（parent_internal-\u0026gt;GetSize() \u0026lt; parent_internal-\u0026gt;GetMaxSize()）{ // 父节点的空间是够的，直接插入就行了 } // 剩下的自然就是空间不够需要进行父节点分裂的情况 ..... parent_internal-\u0026gt;Split(key, new_leaf, new_parent_page, comparator_, buffer_pool_manager_); ...... InsertIntoParent(parent_page, new_parent_internal-\u0026gt;KeyAt(0), new_parent_page, transaction); ...... } ⚠️ internalPage在分裂的时候尽量创建一个tmp空间进行插入和重新的分配，在本实验中直接在原来的页上插入和分配页没有问题，如果maxsize的大小很极限的话，插入一个kv对可能会容不下，发生错误。\nRemove（） remove（）函数的逻辑相较于前两个则是复杂非常多的，但是按照伪代码按图索骥，一步一步来，是能够完美实现的。 auto brother_node = reinterpret_cast\u0026lt;BPlusTreePage *\u0026gt;(brother_page-\u0026gt;GetData()); if (brother_node-\u0026gt;GetSize() + btree_page-\u0026gt;GetSize() \u0026lt;= (btree_page-\u0026gt;IsLeafPage() ? leaf_max_size_ - 1 : internal_max_size_)) { if (is_pre) { std::swap(leaf_page, brother_page); } Coalesce(leaf_page, brother_page, parent_key, transaction); DeleteEntry(parent_page, parent_key, transaction); } else { Redistribute(leaf_page, brother_page, parent_page, parent_key, is_pre, transaction); } ==DeleteEntry()==\n大致梳理一下思路：\n首先找到页之后自然是删除，需要注意的是leaf和internal的组成略有差异，需要分别进行处理 如果所在页是根节点而且只剩下一个子节点需要进行额外的Adjustroot（）函数进行操作。 删除之后发现kv对的数量小于规定的MinSize(),那么进行分类讨论 和兄弟节点合起来Coalesce()的大小没有超过maxSize，但是不同类型的节点maxSize计量方式不同，这也是一个坑点,那就将两个节点合并，但是最后记得把被合并的key从父节点中删除 和兄弟节点合起来的大小超过了maxSize，那么需要Redistribute(),从兄弟节点中协调一个过来。这里分成四种情况，是否是叶子节点，以及兄弟节点在前在后分成了四种情况 ⚠️需要注意的是，root page 并不受 min size 的限制。但如果 root page 被删到 size 只剩 1，即只有一个 child page 的时候，应将此 child page 设置为新的 root page。\n还有两种类的page计算maxSize的逻辑不太一样需要注意一下。\n另外，在合并时，两个 page 合并成一个 page，另一个 page 应该删除，释放资源。删除 page 时，仍是调用 buffer pool 的 DeletePage() 函数。\n==AdjustRoot（）== 根节点只剩一个子节点的时候小小的调整一下。\n==Coalesce()==\n还是要区分是否是leafPage，处理方式不太一样\n如果是leaf节点简简单单的合并到一个节点然后更改一下叶子节点的next指针就够了\n如果是Internal节点的话需要合并完之后更新一下子节点的父节点。\n==Redistribute（）==\n发现不能合并之后就只需要从兄弟节点处协调一个即可 协调的过程比较简单，从左侧节点偷取时，把左侧节点最后一个 KV 对转移至当前节点第一个 KV 对，从右侧节点偷取时，把右侧节点的 KV 对转移至当前节点最后一个 KV 对。leaf page 和 internal page 的偷取过程基本相同，仅需注意 internal page 偷取后更新子节点的父节点指针。\nSummary ckeckpoint1主要的难点就是在细枝末节的处理上，非常的折磨人，我开始没并没有按照严格按照伪代码写，除了很多的奇奇怪怪的bug，最后几乎是推到重来，按照伪代码才算是能正确的运行。\n但是unpin我一直处理不好，卡了我好长时间，最后还是祭出transaction，好好研究了一下才把线上评测过了。\n最后附上通过截图 也是最这一段时间的一个总结。\n","permalink":"https://jialog.top/posts/database/project/cmu15-445-project2-b+-tree-index-checkpoint-1/","summary":"\u003ch2 id=\"一些工具\"\u003e一些工具\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\"\u003eBusTub B+Tree Printer\u003c/a\u003eCMU官方在线的B+树的生成工具。我主要用来细节实现的时候进行参考。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://goneill.co.nz/btree-demo.php\"\u003eJavaScript B+ Tree\u003c/a\u003eB+树插入和删除的动态演示。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0A%0A%20%20subgraph%20cluster_0%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20a0%20-%3E%20a1%20-%3E%20a2%20-%3E%20a3%3B%0A%20%20%20%20label%20%3D%20%22process%20%231%22%3B%0A%20%20%7D%0A%0A%20%20subgraph%20cluster_1%20%7B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%5D%3B%0A%20%20%20%20b0%20-%3E%20b1%20-%3E%20b2%20-%3E%20b3%3B%0A%20%20%20%20label%20%3D%20%22process%20%232%22%3B%0A%20%20%20%20color%3Dblue%0A%20%20%7D%0A%20%20start%20-%3E%20a0%3B%0A%20%20start%20-%3E%20b0%3B%0A%20%20a1%20-%3E%20b3%3B%0A%20%20b2%20-%3E%20a3%3B%0A%20%20a3%20-%3E%20a0%3B%0A%20%20a3%20-%3E%20end%3B%0A%20%20b3%20-%3E%20end%3B%0A%0A%20%20start%20%5Bshape%3DMdiamond%5D%3B%0A%20%20end%20%5Bshape%3DMsquare%5D%3B%0A%7D\"\u003eGraphviz Online\u003c/a\u003e可视化自己的树。在debug的时候会用到。将生成的dot文件转换成svg图片。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.gradescope.com/courses/425272\"\u003eLog In | Gradescope\u003c/a\u003e在线评测网站,邀请码：PXWVR5，\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/project2/\"\u003eProject #2 - B+Tree | CMU 15-445/645 :: Intro to Database Systems (Fall 2022)\u003c/a\u003e最重要的当然还是课程网站了\u003c/li\u003e\n\u003cli\u003e课程的视频，还有对应的教材还是推荐看一下的上面有很多实现细节的。非常值得参考。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"如何debug自己的\"\u003e如何Debug自己的🌳\u003c/h3\u003e\n\u003cp\u003e大致上可以分为两种方式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可视化的用自带的\u003ccode\u003eprinter\u003c/code\u003e将树生成dot文件然后复制到上面的可视化网站。\u003c/li\u003e\n\u003cli\u003e由于本项目采用的是cmake构建的，所以可以很方便的在测试文件中打上断点。进行调试。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e==可视化调试==\u003c/p\u003e\n\u003cp\u003e在终端中执行以下命令，构建和执行\u003ccode\u003eprinter\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"err\"\u003e➜\u003c/span\u003e  \u003cspan class=\"n\"\u003ebuild\u003c/span\u003e \u003cspan class=\"nl\"\u003egit\u003c/span\u003e\u003cspan class=\"p\"\u003e:(\u003c/span\u003e\u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003emake\u003c/span\u003e \u003cspan class=\"n\"\u003eb_plus_tree_printer\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ej2\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 构建printer\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"err\"\u003e➜\u003c/span\u003e  \u003cspan class=\"n\"\u003ebuild\u003c/span\u003e \u003cspan class=\"nl\"\u003egit\u003c/span\u003e\u003cspan class=\"p\"\u003e:(\u003c/span\u003e\u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003eb_plus_tree_printer\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 执行printer  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e执行完之后就会有以下提示：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240202215423.png\"\u003e\u003c/p\u003e\n\u003cp\u003e按照这个提示就可以生成dot文件，然后复制到上述的网站进行可视化。（当你看到自己的树呈现出来的时候还是非常有成就感的😁）\u003c/p\u003e\n\u003cp\u003e==非可视化==\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240202220003.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以很方便的直接打断点，然后在vscode中的cmake插件中选择调试进行debug。\u003c/p\u003e\n\u003cp\u003e官方还提供了一种大打log的方式进行debug，我是不太习惯这种方式所以没有进行很深入的研究。感兴趣的可以自己进行了解😗。\u003c/p\u003e\n\u003cp\u003e两种debug的方式是\u003cstrong\u003e相辅相成的\u003c/strong\u003e，在你过不了\u003cstrong\u003e本地样例\u003c/strong\u003e的时候好好的用非可视化的方式进行debug，线上样例过不了大部分原因是细节处理上出问题了。用可视化的方式会更加的直观。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e请不要公开代码，尊重Andy劳动成果\u003c/em\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"概览\"\u003e概览\u003c/h2\u003e\n\u003cp\u003eProject2是实现B+树索引，整个project大致被分为了两个部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echeckpoint1：实现一个单线程的b+树。\u003c/li\u003e\n\u003cli\u003echeckpoint2：实现一个多线程的b+树。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e实验代码中给出的自由发挥的空间非常的大，只给出了\u003ccode\u003eGetvalue()\u003c/code\u003e,\u003ccode\u003eInsert()\u003c/code\u003e,\u003ccode\u003eRemove()\u003c/code\u003e这三个函数的接口，剩下的所有的实现都非常的自由，整个实验实现的过程就像一个黑盒一样，只在乎输入和输出。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240202220853.png\"\u003e\u003c/p\u003e\n\u003cp\u003e本实验需要完成b+ index部分，b+树中的页（page）都需要从上一个实验中实现的buffer pool中取。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"checkpoint-1\"\u003eCheckpoint-1\u003c/h2\u003e\n\u003ch3 id=\"task-1---btree-pages\"\u003eTask #1 - B+Tree Pages\u003c/h3\u003e\n\u003cp\u003e需要完成以下三个page，主要都是一些getter和setter的函数，重在理解各部分的组成。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/project2/#b\u0026#43;tree-page\"\u003e\u003cstrong\u003eB+Tree Parent Page\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/project2/#b\u0026#43;tree-internal-page\"\u003e\u003cstrong\u003eB+Tree Internal Page\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/project2/#b\u0026#43;tree-leaf-page\"\u003e\u003cstrong\u003eB+Tree Leaf Page\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中parentPage是internal page和leaf page的父类。我更\u003cstrong\u003e倾向于\u003c/strong\u003e把这几个page类型理解为 从buffer pool中取回来的Page的\u003cstrong\u003e不同解释形式\u003c/strong\u003e。Page还是那个Page。主要就是在于你如何去解释它的组成部分。\u003c/p\u003e","title":"CMU15-445-Project #2 - B+ Tree Index Checkpoint 1"},{"content":"数值类型 整数类型 整数就是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型： 整型溢出 在使用编程的过程中难免会发生数的范围超过了类型范围这时候就会发生溢出的现象。\n有趣的是：在debug模式下编译器会检测有没有发生整形溢出的现象，如果有发生整数溢出的现象编译就会发生panic.\n但是在release模式下，编译器不会进行整数溢出的的检测。当发生整数溢出的时候会按照补码循环溢出进行处理。简单来讲就是取余。\n要显式的处理可能的溢出，可以使用标准库提供的类型。\n使用warpping_*的方法在所有模式下都按照补码循环溢出的规则进行处理 使用check_*方法发生溢出的时候返回None值。 使用overflowing_*方法返回该值和是否溢出的一个bool值 使用saturating_*的方法返回最大值或者最小值 下面是一个演示warpping_*的一个示例代码\nfn main() { let a : u8 = 255; let b = a.wrapping_add(20); println!(\u0026#34;{}\u0026#34;, b); // 19 } 最后这个输出结果也没有出乎意料。\n浮点类型 浮点类型是带有小数点的数字。在Rust中浮点数类型也有两种表示f32,f64. 分别表示32位和64位。在现代CPU中32位的运算速度几乎和64位是一样的。所以默认是f64.\n浮点数陷阱 浮点数在其底层表示上有很大的特殊性，这就导致了如果在使用的时候不够谨慎就会造成危险。主要有以下两个原因。\n浮点数是一种近似的表达。由于所有的生活中的数字我们都是用十进制进行标识但是计算机用二进制在底层进行表示，所以我们很难非常准确的表示十进制的小数。 浮点数在某一些事情上是反直觉的。例如很多人都觉得浮点数是可以进行比较的对吧。但是实际上如果我们编写如下的代码会发生什么呢？ fn main(){ assert!(0.1+0.2==0.3); } 程序将会panic，因为二进制精度 的问题，0.1+0.2将会在N位之后与0.3发生偏差。\n为了避免掉入陷阱当中，我们需要注意以下两点。\n避免在浮点数上测试相等性 当结果在数学上存在未定义的时候我们需要格外的小心 但是如果非要进行比较呢？ 可以考虑用这种方式 (0.1_f64 + 0.2 - 0.3).abs() \u0026lt; 0.00001 ，具体小于多少，取决于你对精度的需求。\n但是事情到这还没完。\n我们对0.1+0.2的f32和f64两种形式进行比较。\nfn main() { let abc: (f32, f32, f32) = (0.1, 0.2, 0.3); let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3); println!(\u0026#34;abc (f32)\u0026#34;); println!(\u0026#34; 0.1 + 0.2: {:x}\u0026#34;, (abc.0 + abc.1).to_bits()); println!(\u0026#34; 0.3: {:x}\u0026#34;, (abc.2).to_bits()); println!(); println!(\u0026#34;xyz (f64)\u0026#34;); println!(\u0026#34; 0.1 + 0.2: {:x}\u0026#34;, (xyz.0 + xyz.1).to_bits()); println!(\u0026#34; 0.3: {:x}\u0026#34;, (xyz.2).to_bits()); println!(); assert!(abc.0 + abc.1 == abc.2); assert!(xyz.0 + xyz.1 == xyz.2); } 我们会发现在32位的情况下是可以通过的但是在64位的情况下是会panic的。\nNaN NaN:(not a number) 不是一个合法的数。就会出现这个标识。所有和NaN的交互操作都会返回NaN。\nNaN不能用于比较 但是NaN可以用于判断是否是NaN。 数字运算 就是一般的四则运算等等。\n序列（Range） ..=这个符号表示序列，下面举个例子。\nfor i in 1..=5{ println!(\u0026#34;{}\u0026#34;,i); } 使用As进行类型转换 这里先按下不表，在后续的进阶过程中会进行详细的了解。\n有理数和复数 Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：\n有理数和复数 任意大小的整数和任意精度的浮点数 固定精度的十进制小数，常用于货币相关的场景 好在社区已经开发出高质量的 Rust 数值库：num。\n按照以下步骤来引入 num 库：\n创建新工程 cargo new complex-num \u0026amp;\u0026amp; cd complex-num 在 Cargo.toml 中的 [dependencies] 下添加一行 num = \u0026quot;0.4.0\u0026quot; 将 src/main.rs 文件中的 main 函数替换为下面的代码 运行 cargo run。 use num::complex::Complex; fn main() { let a = Complex { re: 2.1, im: -1.2 }; let b = Complex::new(11.1, 22.2); let result = a + b; println!(\u0026#34;{} + {}i\u0026#34;, result.re, result.im) } 我觉得这个例子主要让我学习了导包的过程。\n数值类型的总结 之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：\nRust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数 类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数 Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型 数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。\n布尔类型 ","permalink":"https://jialog.top/posts/rust/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","summary":"\u003ch2 id=\"数值类型\"\u003e数值类型\u003c/h2\u003e\n\u003ch3 id=\"整数类型\"\u003e整数类型\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003e整数\u003c/em\u003e就是没有小数部分的数字。之前使用过的 \u003ccode\u003ei32\u003c/code\u003e 类型，表示有符号的 32 位整数（ \u003ccode\u003ei\u003c/code\u003e 是英文单词 \u003cem\u003einteger\u003c/em\u003e 的首字母，与之相反的是 \u003ccode\u003eu\u003c/code\u003e，代表无符号 \u003ccode\u003eunsigned\u003c/code\u003e 类型）。下表显示了 Rust 中的内置的整数类型：\n\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240107164516.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"整型溢出\"\u003e整型溢出\u003c/h4\u003e\n\u003cp\u003e在使用编程的过程中难免会发生数的范围超过了\u003cstrong\u003e类型范围\u003c/strong\u003e这时候就会发生溢出的现象。\u003c/p\u003e\n\u003cp\u003e有趣的是：在\u003ccode\u003edebug\u003c/code\u003e模式下编译器会检测有没有发生整形溢出的现象，如果有发生整数溢出的现象编译就会发生\u003ccode\u003epanic\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e但是在\u003ccode\u003erelease\u003c/code\u003e模式下，编译器\u003cstrong\u003e不会\u003c/strong\u003e进行整数溢出的的检测。当发生整数溢出的时候会按照\u003cem\u003e补码循环溢出\u003c/em\u003e进行处理。简单来讲就是\u003cstrong\u003e取余\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e要显式的处理可能的溢出，可以使用标准库提供的类型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用\u003ccode\u003ewarpping_*\u003c/code\u003e的方法在所有模式下都按照补码循环溢出的规则进行处理\u003c/li\u003e\n\u003cli\u003e使用\u003ccode\u003echeck_*\u003c/code\u003e方法发生溢出的时候返回\u003ccode\u003eNone\u003c/code\u003e值。\u003c/li\u003e\n\u003cli\u003e使用\u003ccode\u003eoverflowing_*\u003c/code\u003e方法返回该值和是否溢出的一个bool值\u003c/li\u003e\n\u003cli\u003e使用\u003ccode\u003esaturating_*\u003c/code\u003e的方法返回最大值或者最小值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面是一个演示\u003ccode\u003ewarpping_*\u003c/code\u003e的一个示例代码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e: \u003cspan class=\"kt\"\u003eu8\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewrapping_add\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 19\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e最后这个输出结果也没有出乎意料。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240107183105.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"浮点类型\"\u003e浮点类型\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e浮点类型\u003c/strong\u003e是带有小数点的数字。在Rust中浮点数类型也有两种表示\u003ccode\u003ef32\u003c/code\u003e,\u003ccode\u003ef64\u003c/code\u003e.\n分别表示32位和64位。在现代CPU中32位的运算速度几乎和64位是一样的。所以默认是\u003ccode\u003ef64\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"浮点数陷阱\"\u003e浮点数陷阱\u003c/h4\u003e\n\u003cp\u003e浮点数在其底层表示上有很大的特殊性，这就导致了如果在使用的时候不够谨慎就会造成危险。主要有以下两个原因。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e浮点数是一种近似的表达\u003c/strong\u003e。由于所有的生活中的数字我们都是用十进制进行标识但是计算机用二进制在底层进行表示，所以我们很难非常准确的表示十进制的小数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e浮点数在某一些事情上是反直觉的\u003c/strong\u003e。例如很多人都觉得浮点数是可以进行比较的对吧。但是实际上如果我们编写如下的代码会发生什么呢？\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"fm\"\u003eassert!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.1\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.2\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.3\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e程序将会panic，因为二进制精度 的问题，0.1+0.2将会在N位之后与0.3发生偏差。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20240107190957.png\"\u003e\u003c/p\u003e\n\u003cp\u003e为了避免掉入陷阱当中，我们需要注意以下两点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e避免在浮点数上测试相等性\u003c/li\u003e\n\u003cli\u003e当结果在数学上存在未定义的时候我们需要格外的小心\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e但是如果\u003cstrong\u003e非要\u003c/strong\u003e进行比较呢？\n可以考虑用这种方式 \u003ccode\u003e(0.1_f64 + 0.2 - 0.3).abs() \u0026lt; 0.00001\u003c/code\u003e ，具体小于多少，取决于你对精度的需求。\u003c/p\u003e","title":"基本类型"},{"content":"一些关于为什么要学rust的想法 其实在大一的时候我就有了解过rust语言，当时甚至还看了一周b站的视频，在我最近准备再看rust的时候发现我大一装的环境还在，我甚至自己都不记得有这件事了。\nrust语言据说有非常好的内存管理机制和安全措施，以及极高的执行效率，所以近些年被用作开发底层非常的多，而我对这方面也是非常的感兴趣，也算是兴趣驱动吧。希望能有助于提高一下自己的编程能力，让自己也多了解一下rust语言。\n","permalink":"https://jialog.top/posts/rust/some-ideas/","summary":"\u003ch2 id=\"一些关于为什么要学rust的想法\"\u003e一些关于为什么要学rust的想法\u003c/h2\u003e\n\u003cp\u003e其实在大一的时候我就有了解过rust语言，当时甚至还看了一周b站的视频，在我最近准备再看rust的时候发现我大一装的环境还在，我甚至自己都不记得有这件事了。\u003c/p\u003e\n\u003cp\u003erust语言据说有非常好的内存管理机制和安全措施，以及极高的执行效率，所以近些年被用作开发底层非常的多，而我对这方面也是非常的感兴趣，也算是兴趣驱动吧。希望能有助于提高一下自己的编程能力，让自己也多了解一下rust语言。\u003c/p\u003e","title":"some ideas"},{"content":"auto 在概念上auto已经极简了，但是实际上仍然要微妙许多。它可以节约声明类型，也可以避免许多手动类型的正确性和声明问题。但是从结果的角度来说，尽管auto很努力在做事了，但是仍然可能是错误的。如果出现这种情况我们要知道如何去引导auto让他成为正确的类型，因为退回使用手动声明类型仍然是下下策。\n接下来的内容会涵盖auto的所有细节\nItem 5: Prefer auto to explicit type declarations. 不仅可以避免出现为初始化的变量，避免啰嗦又繁杂的类型声明，能直接持有闭包，还可以避免一些因为“类型捷径”出现的问题。 eg1.\n有一些程序员会对类型发生误判，到时用范围较小的类型在32位机器上能够运行但是在64位机器上发生了改变，导致程序在移植的时候出现问题。 eg2. 上述代码看起来没什么问题，但是当实际运行之后并没有对哈希表m进行操作。原因在于哈希表中的kay值是const类型的，手动声明的类型不一样的话编译器会进行一个神奇的操作，它会讲m中的内容复制成为临时变量将key的类型改为和声明一致的，再将p绑定到临时变量上。\nSummary auto说到底只是一个可选项罢了，不是必选项，如果你觉得你的项目使用显式的声明能够使得项目变得更加的可读和高效，当然可以继续使用。但是c++引入auto并不是一个多新鲜的东西，只是一个在其他语言中被称为“类型推导”的东西罢了。在其他的静态类型语言中类型推导都或多或少存在。而且动态语言还为类型推导积累了大量的经验。而且此类技术并不会于大型的工程项目产生冲突。\n一些人觉得用完auto之后会让变量的类型变得不是一眼可以识别，但是这个问题随着ide的优化和适配已经被解决的相当完美了。\n事实上手动声明变量经常是在画蛇添足，无论是正确率还是效率上。\nItem 6: Use the explicitly typed initializer idiom when auto deduces undesired types. 纵使auto有万般好，但是auto也会出现推断的类型和你心目中期待的不一样的情况（当然也不完全是auto错了哦😀） 下面举一个auto推断不符合预期的例子。\n上述声明了一个返回vector\u0026lt; bool \u0026gt;类型的函数，使用了auto之后虽然仍然能够直接进行编译和运行但是结果却不是所想要的。\n而发生这样错误的原因是，在c++的设计当中回避了bit的引用所以返回的不是bool\u0026amp;，实际上c++中设计了一个代理类来完成向bool的转换操作，这就不展开细说了，但是代理类并不少见，我们经常使用的两个智能指针就是一种代理类。\n代理类的设计在使用的时候尽量少的对程序员暴露内部细节，这些代理类的使用往往会在文档中标识出来，如果在文档中没有体现的话，也避免不了在头文件中漏出一些破绽，最不济在debug的时候可能也会发觉是使用了代理类。\n但是这些都不重要了，现在重要的事怎么把auto引导到正确的道路上🙃。\n就是使用一个强制的类型转换，让它去到该去的位置，虽然看起来有点滑稽，给人一种头痛医脚的感觉🤣。虽然在这些时候你也可以放弃使用auto，但是在这个踩坑的过程中不是也收获了新的知识么?😁\n总之记住以下两点 隐形的代理类可能会让auto推断出错误的类型。 显式的类型转换可以让auto走向正确道路。 Moving to Modern C++ 接下来这一章会详细介绍现代c++的一些细节特性。我自己会记录几个我认为比较实用的。并不是全部。\nItem 8: Prefer nullptr to 0 and NULL. 非常显然的是0的类型是int，不是一个指针，但是在一个本应该出现指针类型的地方出现了0，编译器也会勉强吧0解释为空指针，但这毕竟是不得已而为之的行为🙉， 总之0是int，不是指针。\nnullptr’s advantage is that it doesn’t have an integral type. To be honest, it doesn’t have a pointer type, either, but you can think of it as a pointer of all types. nullptr’s actual type is std::nullptr_t, and, in a wonderfully circular definition, std::nullptr_t is defined to be the type of nullptr. The type std::nullptr_t implicitly converts to all raw pointer types, and that’s what makes nullptr act as if it were a pointer of all types.\n所以用nullptr总会的到正确类型的空指针，而不用编译器进行不情愿的转换。不仅如此，使用nullptr还会提高代码的可读性。\n通过以上两段代码的对比我相信很快就能感觉到差距所在。其实最重要的是在使用auto的时候0和null可能会进行错误的推导。\n尽量采用nullptr而不是0或者null 避免在整形和指针类型之间的重载。 Item 12: Declare overriding functions override. 在需要重写的函数中添加override声明，好处就是能减少出错的几率吧，算是一个编程的好习惯。\nItem 13: Prefer const_iterators to iterators. 在c++11之前中标准库中缺少cbegin和cend这样带有c语言风格的函数，但是实际上const的begin（）和cbegin（）几乎是没有任何区别的，不知道为什么要这样设计，据说是成员函数设计与自由函数设计之争🙃？不是很懂。\n总之使用const_iterators是有好处的，起码你的代码变得标准起来了不是么？\nItem 16: Make const member functions thread safe. 当我们用一个类表示多项式会非常的方便，一般会有一个计算多项式根的函数，这个多项式一般不会造成多项式值的改动，所以把这个函数声明为const成员函数是一件非常正常的事情。\n（item9是说优先使用别名而不是typedefs）\n由于计算机计算多项式解的过程开销是非常大的，所以即使是计算也会把结果缓存起来，减小开销，以下是一种基本的做法：\n在一般的const函数中不会改变任何值，但是在本例中，由于根的组成部分不只是值还有一些标志位，在求值的过程中标志位会发生改变。\n这两个线程就会产生不安全的行为。最常见的解决办法就是加入互斥变量。\n但是用latch似乎有点杀鸡用牛刀了。\n如果只是记录函数的调用次数并且保证其他函数能够观测到这一行为可以使用 std::atomic counter，下面将演示如何使用这个原子的计数器。 但是需要谨慎的使用这个原子的计数器，以下是两个反例。\n在这个例子中假如第一个线程进行到=true的部分，这时第二个线程进入发现标识位为true于是返回了一个不是经过计算的值。\n如果将这两个句子的顺序颠倒会发生一些不一样的东西么？ 答案是不会。这个函数仍然是不完美的\n因为延迟修改标志位，所以有可能会出现重复的计算。\n对于拥有两个以上的需要同步的变量尽量采用mutex吧。 以下是一个好的示范。\n保证const成员函数的线程安全 使用原子的计数器，但是需要谨慎。 Smart Pointers 原始指针虽然非常的强大，但是往往伴随着以下几点问题：\n指针的声明并不能直观看出是指向一个对象或者一个数组。eg.一个int和一个int数组的指针都是int*。 不知道在使用之后是否应该销毁指针所指的对象。也就是说不知道指针是否拥有所指对象。 即使知道了所指的对象也不确定具体的销毁方法，是用delete还是其他特殊的析构函数。 如果知道了用delete是可行的，但是由于原因1，所以不知道delete一个对象还是delete[]一个数组。 没有什么方法能可靠的检测悬空的指针。 智能指针是解决这种问题的一种方法，智能指针是对原始指针的一种包装。行为很类似，却能避免很多坑，所以在日常的代码中应该优先选用智能指针而非裸指针。\n在我接触到的代码中智能指针基本上就会用两个：std::unique_ptr和std::shared_ptr。\nItem 18: Use std::unique_ptr for exclusive-ownership resource management. 当你需要使用智能指针的时候std::unique_ptr几乎就是首选，它拥有和裸指针差不多的大小，各种操作的效率也差不多。如果裸指针能够满足要求的话，那么std::unique_ptr也一定可以的。\nstd::unique_ptr实现的是专属所有权语义。一个非空的std::unique_ptr总是拥有其对对象的所有权，除非用std::move()函数把所有权从原指针“移动到”目标指针，原指针则会被置为空。但是std::unique_ptr绝对不允许进行复制。\n同时也可以使用get（）函数返回裸指针\nstd::unique_ptr可以非常方便的转换为std::shared_ptr 这就为代码的规范化编写提供了很多的方便。\nstd::unique_ptr是一种高速，小巧，只具有移动语义的对对象想有专属所有权的智能指针。 默认情况下，析构函数是delete，但是也可以手动指定析构函数。 将其转化为std::shared_ptr是非常容易的 ","permalink":"https://jialog.top/posts/c++/effective-modern-c++/","summary":"\u003ch2 id=\"auto\"\u003eauto\u003c/h2\u003e\n\u003cp\u003e在概念上auto已经极简了，但是实际上仍然要微妙许多。它可以节约声明类型，也可以避免许多手动类型的正确性和声明问题。但是从结果的角度来说，尽管auto很努力在做事了，但是仍然可能是错误的。如果出现这种情况我们要知道如何去引导auto让他成为正确的类型，因为退回使用手动声明类型仍然是下下策。\u003c/p\u003e\n\u003cp\u003e接下来的内容会涵盖\u003ccode\u003eauto\u003c/code\u003e的所有细节\u003c/p\u003e\n\u003ch3 id=\"item-5-prefer-auto-to-explicit-type-declarations\"\u003eItem 5: Prefer auto to explicit type declarations.\u003c/h3\u003e\n\u003cp\u003e不仅可以避免出现为初始化的变量，避免啰嗦又繁杂的类型声明，能直接持有闭包，还可以避免一些因为“类型捷径”出现的问题。\neg1.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231210204514.png\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e有一些程序员会对类型发生误判，到时用范围较小的类型在32位机器上能够运行但是在64位机器上发生了改变，导致程序在移植的时候出现问题。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eeg2.\n\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231210205424.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上述代码看起来没什么问题，但是当实际运行之后并没有对哈希表m进行操作。原因在于哈希表中的kay值是const类型的，手动声明的类型不一样的话编译器会进行一个神奇的操作，它会讲m中的内容复制成为临时变量将key的类型改为和声明一致的，再将p绑定到临时变量上。\u003c/p\u003e\n\u003ch4 id=\"summary\"\u003eSummary\u003c/h4\u003e\n\u003cp\u003eauto说到底只是一个可选项罢了，不是必选项，如果你觉得你的项目使用显式的声明能够使得项目变得更加的可读和高效，当然可以继续使用。但是c++引入auto并不是一个多新鲜的东西，只是一个在其他语言中被称为“类型推导”的东西罢了。在其他的静态类型语言中类型推导都或多或少存在。而且动态语言还为类型推导积累了大量的经验。而且此类技术并不会于大型的工程项目产生冲突。\u003c/p\u003e\n\u003cp\u003e一些人觉得用完auto之后会让变量的类型变得不是一眼可以识别，但是这个问题随着ide的优化和适配已经被解决的相当完美了。\u003c/p\u003e\n\u003cp\u003e事实上手动声明变量经常是在画蛇添足，无论是正确率还是效率上。\u003c/p\u003e\n\u003ch3 id=\"item-6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types\"\u003eItem 6: Use the explicitly typed initializer idiom when auto deduces undesired types.\u003c/h3\u003e\n\u003cp\u003e纵使auto有万般好，但是auto也会出现推断的类型和你心目中期待的不一样的情况（当然也不完全是auto错了哦😀）\n下面举一个auto推断不符合预期的例子。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|650\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231210214843.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上述声明了一个返回vector\u0026lt; bool \u0026gt;类型的函数，使用了auto之后虽然仍然能够直接进行编译和运行但是结果却不是所想要的。\u003c/p\u003e\n\u003cp\u003e而发生这样错误的原因是，在c++的设计当中回避了bit的引用所以返回的不是bool\u0026amp;，实际上c++中设计了一个\u003cstrong\u003e代理类\u003c/strong\u003e来完成向bool的转换操作，这就不展开细说了，但是代理类并不少见，我们经常使用的两个智能指针就是一种代理类。\u003c/p\u003e\n\u003cp\u003e代理类的设计在使用的时候尽量少的对程序员暴露内部细节，这些代理类的使用往往会在文档中标识出来，如果在文档中没有体现的话，也避免不了在头文件中漏出一些破绽，最不济在debug的时候可能也会发觉是使用了代理类。\u003c/p\u003e\n\u003cp\u003e但是这些都不重要了，现在重要的事怎么把auto引导到正确的道路上🙃。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|700\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231210220544.png\"\u003e\u003c/p\u003e\n\u003cp\u003e就是使用一个强制的类型转换，让它去到该去的位置，虽然看起来有点滑稽，给人一种头痛医脚的感觉🤣。虽然在这些时候你也可以放弃使用auto，但是在这个踩坑的过程中不是也收获了新的知识么?😁\u003c/p\u003e\n\u003cp\u003e总之记住以下两点\n\u003cimg alt=\"image.png|700\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231210220919.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e隐形的代理类可能会让auto推断出错误的类型。\u003c/li\u003e\n\u003cli\u003e显式的类型转换可以让auto走向正确道路。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"moving-to-modern-c\"\u003eMoving to Modern C++\u003c/h2\u003e\n\u003cp\u003e接下来这一章会详细介绍现代c++的一些细节特性。我自己会记录几个我认为比较实用的。并不是全部。\u003c/p\u003e\n\u003ch3 id=\"item-8-prefer-nullptr-to-0-and-null\"\u003eItem 8: Prefer nullptr to 0 and NULL.\u003c/h3\u003e\n\u003cp\u003e非常显然的是0的类型是\u003cstrong\u003eint\u003c/strong\u003e，不是一个指针，但是在一个本应该出现指针类型的地方出现了0，编译器也会勉强吧0解释为空指针，但这毕竟是不得已而为之的行为🙉， 总之0是int，不是指针。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003enullptr’s advantage is that it doesn’t have an integral type. To be honest, it doesn’t have a pointer type, either, but you can think of it as a pointer of all types. nullptr’s actual type is std::nullptr_t, and, in a wonderfully circular definition, std::nullptr_t is defined to be the type of nullptr. The type std::nullptr_t implicitly converts to all raw pointer types, and that’s what makes nullptr act as if it were a pointer of all types.\u003c/p\u003e","title":"Effective Modern C++ 笔记"},{"content":"环境搭建 按照P0的指导中进行环境的搭建，由于我本人现在时WIN平台，课程没有提供一键配置环境的脚本，所以我选择云服务器进行环境的构建，很稳。\n但是我的云服务器配置只有2核2G在编译的时候会爆内存。这里还有个故事，在爆内存之后我已经意识到这个问题，我给阿里云客服提了个工单试图能白嫖一些配置，客服还是很有水平的，直接就分析出来我是内存爆了导致的，但是直接建议我加钱升级配置，不告诉我设置swap分区，有点不厚道了。\n话说回来，设置完swap分区之后就没有再出现过爆内存的现象。用VScode的远程开发，体验还是很不错的。\nOverview p1主要是内存管理部分的内容，这门课程的课本和录制视频还是很有必要看一下的。\n主要的任务是以下三个部分：\n可扩展的哈希表 LRU-K的淘汰策略的视线 Buffer Pool的一个实例 在开始梳理项目之前我想要先解释清楚一下三个任务之间的关系，以及各个部分的负责。\nframe更像是一个载体，而page是其中的内容。打个比方来说，一个仓库（buffer pool）只有100辆货车（frame），而货物（page）成千上万种，每次都是仓库告诉货车需要什么货物然后由货车带着货物来到仓库，而可扩展的哈希表就是登记货车和货物的对应关系。因为只有100辆货车，当每辆车都是满的时候（没有闲置的车辆free_list不为空）就需要根据task2的LRU-K算法挑选出一个符合要求的货车清空后去装载指定的货物。 而task3就是负责整个的管理和交互。\n大概解释了一下，可能比方不是很恰当，做的时候一定要多看文档和注释，因为漏看注释给我带来了极大的痛苦。\nTask #1 -ExtendibleHashTable 相关函数 Find(K,V): 查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回false Insert(K,V): 插入一个（K，V），如果插入失败需要进行一下步骤的重试： 插入失败肯定是桶满了，但是桶满了分为两种不同的情况。 一种是global深度和桶的local深度不相同的时候，需要对桶进行重新的分配。 当两个深度相同的时候说明桶是真的满了，需要对哈希表进行扩展 Remove(K): 在哈希表中移除对应的（K，V）对，但是需要进行哈希表缩小的操作。 IndexOf(K): 当前global深度下的映射规则。 项目架构 首先要清楚这个是自己动手实现一个可扩展哈希表用于保存frame和page的映射关系的。我觉得首先要明白frame和page之间的关系。不清楚的可以回看上文的解释。\nBucket 存储桶 在可可以扩展的哈希表种引入和Bucket的概念，用于解决哈希冲突的问题，每一个Bucket的大小都是固定的，当一个Bucket满了的时候就需要进行哈希表的扩展。\nBucket的组成 depth_：表示本地深度的一个标识，用于识别当前的深度是否和全局深度相同。要特别注意这个变量。 list_：发生哈希冲突时保存多个（K，V）映射的双向链表。 size：为了保证效率，list的长度不能无限延伸，所以达到一定长度的时候要进行哈希表的扩展。 可扩展的哈希表结构 Bucket_size:用于限制每个bucket的list的长度 dir_:用于哈西运算后保存映射关系。 global_depth_:全局深度，在插入的时候根据全局深度和局部深度来确定这个桶是否要进行重新的分配。 num_buckets:用于统计现在一共有多少bucket。 ReHash的过程详解 1.hash的规则是什么样的\ntemplate \u0026lt;typename K, typename V\u0026gt; auto ExtendibleHashTable\u0026lt;K, V\u0026gt;::IndexOf(const K \u0026amp;key) -\u0026gt; size_t { int mask = (1 \u0026lt;\u0026lt; global_depth_) - 1; return std::hash\u0026lt;K\u0026gt;()(key) \u0026amp; mask; } 上述函数就是该哈希表的映射规则，总的来说就是取hash函数值的低global_depth位\n假如现在global_depth_的值为3。 那么 1 \u0026lt;\u0026lt; global_depth_的值就是8转换为二进制就是 1000 。mask=8-1=7，转换为二进制就是 111.\nmask 的作用就是取一个位数和global_depth_一样的全1的二进制数，为了取低global_depth_位做铺垫。\n现在假如key的值进行完hash之后是 10110100011010 和 mask进行进行 \u0026amp; 的操作之后就变成了 010 （低3位）\n刚开始的时候我看这个函数设计左移操作和\u0026amp;操作很复杂的样子，我就没怎么在意，不是很懂这个函数在干什么。但是现在想来 mask 应该是掩码的意思，所以和计网里掩码的作用是一样的，都是取二进制数位的作用。\n这个函数没搞懂真的给我带来很大的困扰，一直搞不懂到底是怎么映射的。\n2.什么时候进行ReHash，以及详细过程。\n当一个桶内的list长度达到规定上限的时候进行Rehash。\n但不是立刻将所有桶内的映射关系都立刻进行重新分配。因为当哈希表比较大的时候这样会带来瞬时的高负载，给机器带来不必要的负担。\n那么什么时候对扩展哈希表后的桶内的（k,v）进行重新的映射呢？\n可以认为是什么时候用上了什么时候再进行重新的映射。这里就提现了局部深度和全局深度的作用。如果我们将每一次哈希表的扩展都立即为一次版本的迭代的话。那么局部深度和全局深度就分别代表了桶所处的版本和现在的最近版本。这样就能实现对哈希表的线性时间扩展。\n我们可以想象这样一个过程，现在全局版本为V3（global_depth_=3）而某个桶的局部版本为V2（local_depth_=2）. 这时候我们刚好需要向这个桶中插入一个数据，这时候发现不仅这个桶满了而且还落后版本，我们首先要做的就是更新桶的版本，把桶里面不符合新的映射规则（比原来多一位）的给送到新桶里。\n这里有一个小坑：哈希表扩展后，取哈希的规则随之而改变，所以当要Find一个page的时候就有可能会映射到新的位置上，但是原来的桶内在没插满之前是不会进行重新分配的这时该如何保证能找到这个数据呢？\n下面用一个例子解释一下这个过程。 假设现在取低 1 位 也就是global=1，假设现在来了一个101需要插入而刚好满了需要进行扩容操作。 这里也给了上边那个小坑的答案，就是在扩展哈希表的时候后面新扩展出来的仍然指向原来的桶。\n插入101之后原来 1 对应的桶被重新分配 分别对应01 和 11而原来的 0 对应的桶因为还没有需要插入的数据所以不进行重新分配。当需要的时候再进行重新的分配。\n这样就保证了扩展是线性的，不会每一次扩展的时候负载激增。 可以理解为“懒扩展”。\n具体代码实现 因为教授的要求不能放出全部的源代码所以我只给出关键部分\ntemplate \u0026lt;typename K, typename V\u0026gt; auto ExtendibleHashTable\u0026lt;K, V\u0026gt;::RedistributeBucket(std::shared_ptr\u0026lt;Bucket\u0026gt; bucket) -\u0026gt; void { bucket-\u0026gt;IncrementDepth(); size_t deepth = bucket-\u0026gt;GetDepth(); num_buckets_++; std::shared_ptr\u0026lt;Bucket\u0026gt; new_bucket = std::make_shared\u0026lt;Bucket\u0026gt;(bucket_size_, deepth); size_t pre_hash_sign = std::hash\u0026lt;K\u0026gt;()((bucket-\u0026gt;GetItems().begin())-\u0026gt;first) \u0026amp; ((1 \u0026lt;\u0026lt; (deepth - 1)) - 1); // 遍历原来的bucket进行符合要求就是新老哈希值不一样的就放进新桶里 for (auto i = bucket-\u0026gt;GetItems().begin(); i != bucket-\u0026gt;GetItems().end();) { size_t temp_hash_sign = std::hash\u0026lt;K\u0026gt;()(i-\u0026gt;first) \u0026amp; ((1 \u0026lt;\u0026lt; (deepth)) - 1); if (pre_hash_sign != temp_hash_sign) { new_bucket-\u0026gt;Insert(i-\u0026gt;first, i-\u0026gt;second); bucket-\u0026gt;GetItems().erase(i++); } else { i++; } } // 就该把新桶放在后边那新位置 // size_t new_hash_sign= std::hash\u0026lt;K\u0026gt;()((new_bucket-\u0026gt;GetItems().begin())-\u0026gt;first) \u0026amp; ((1 \u0026lt;\u0026lt; (deepth)) -1 ); for (size_t i = 0; i \u0026lt; dir_.size(); i++) { if ((i \u0026amp; ((1 \u0026lt;\u0026lt; (deepth)) - 1)) != pre_hash_sign \u0026amp;\u0026amp; (i \u0026amp; ((1 \u0026lt;\u0026lt; (deepth - 1)) - 1)) == pre_hash_sign) { dir_[i] = new_bucket; } } } template \u0026lt;typename K, typename V\u0026gt; void ExtendibleHashTable\u0026lt;K, V\u0026gt;::Insert(const K \u0026amp;key, const V \u0026amp;value) { // UNREACHABLE(\u0026#34;not implemented\u0026#34;); std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(latch_); while (true) { size_t index = IndexOf(key); if (dir_[index]-\u0026gt;Insert(key, value)) { break; } // 判断当前bucket的depth和全局depth 如果相同就进行哈希表的扩容操作，如果不相同就进行桶的重新分配 // 这样做的一个好处就是时间复杂度是线性的，不会遇到桶满的时候就负载激增，导致效率下降。 if (GetLocalDepthInternal(index) != GetGlobalDepthInternal()) { RedistributeBucket(dir_[index]); } else { global_depth_++; size_t size = dir_.size(); // 这里就是在扩展后将指针指向对应的老桶就是扩展前的桶。 for (size_t i = 0; i \u0026lt; size; i++) { dir_.emplace_back(dir_[i]); } } } } Task #2 LRU-K LRU-K Replacer Design LRU-K Replacer 用于存储 buffer pool 中 page 被引用的记录，并根据引用记录来选出在 buffer pool 满时需要被驱逐的 page。\nLRU 应该都比较熟悉了，LRU-K 则是一个小小的变种,出现的目的是为了在一定程度上解决缓存污染的问题，有兴趣的可以读一下有关论文，有很详细的介绍。 cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf\n在普通的 LRU 中，我们仅需记录 page 最近一次被引用的时间，在驱逐时，选择最近一次引用时间最早的 page。\n在 LRU-K 中，我们需要记录 page 最近 K 次被引用的时间。假如 list 中所有 page 都被引用了大于等于 K 次，则比较最近第 K 次被引用的时间，驱逐最早的。假如 list 中存在引用次数少于 K 次的 page，则将这些 page 挑选出来，用普通的 LRU 来比较这些 page 第一次被引用的时间，驱逐最早的。\n所有的page大概能够分为两类：\n达到k次的，那么则选择distance最大的进行淘汰 没有达到k次的，就根据普通的LRU进行淘汰 具体实现不是很难，按照给的注释一步步写就好了 刚开始我建议先去力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台写一下这个LRU，实现的思路不能说差不多也能说是差不多。\n对于数据结构的组织我推荐2023fall封装好的这个，我自己做的是2022fall没有这个封装，需要自己设计，给出了一个推荐的方案，对于一个项目的起步还是非常友好的。\nclass LRUKNode { private: std::list\u0026lt;size_t\u0026gt; history_; size_t k_; frame_id_t fid_; bool is_evictable_{false}; }; std::unordered_map\u0026lt;frame_id_t, LRUKNode\u0026gt; node_store_; 只有一个需要注意的点：在SetEvictable 这个函数中只有发生改变才修改curr_size_（可驱逐的个数）这个变量。\nTask# 3-Buffer Pool Manager 这个我认为最主要的就是要厘清各个函数之间的关系\n/** Array of buffer pool pages. */ Page *pages_; /** Page table for keeping track of buffer pool pages. */ ExtendibleHashTable\u0026lt;page_id_t, frame_id_t\u0026gt; *page_table_; /** Replacer to find unpinned pages for replacement. */ LRUKReplacer *replacer_; /** List of free frames that don\u0026#39;t have any pages on them. */ std::list\u0026lt;frame_id_t\u0026gt; free_list_; 上述的定义要和初始化函数结合在一起看\n// we allocate a consecutive memory space for the buffer pool pages_ = new Page[pool_size_]; page_table_ = new ExtendibleHashTable\u0026lt;page_id_t, frame_id_t\u0026gt;(bucket_size_); replacer_ = new LRUKReplacer(pool_size, replacer_k); // Initially, every page is in the free list. for (size_t i = 0; i \u0026lt; pool_size_; ++i) { free_list_.emplace_back(static_cast\u0026lt;int\u0026gt;(i)); } 结合注释不难发现他们之间的关系\npages_:Array of buffer pool pages 。buffer pool的一个数组。他的下标就是frame_id。 page_table_:记录page和frame之间的映射关系。 replacer_: 记录访问历史，在free_list中没有空闲frame可以承载page的时候进行驱逐。 free_list:表示有无空闲的frame可供使用 上图引用自：BusTub Lab1 Buffer Pool Manager | Fischer.space\n这个图很好的解释了三者之间的关系以及各部分所负责的东西。\n接下来梳理一下task3中比较重要的部分\nNewPgImp()和FetchPgImp() 两个函数有很大一部分都是相同的 重点也是这相同的一部分\n先来看NewPgImp() 的要求：\nCreate a new page in the buffer pool. Set page_id to the new page\u0026rsquo;s id, or nullptr if all frames are currently in use and not evictable (in another word, pinned)\n就是新建一个页，但是新建页的过程非常的有讲究：\n首先需要找到一个空闲的frame_承载这个page，优先从free_list中找frame 如果free_list中不存在的话，就需要在replacer_中用驱逐函数将一个frame上的page数据清空，清空在table里的映射关系。用来承载新建的page。 在驱逐的时候如果原来的页是脏的要先吧脏页写回磁盘，防止数据的丢失 之后就是页的初始化操作，注意要顾及到每一个变量。 将新的映射关系写入table，新的访问历史放入replacer\nFetchPgImp() 的流程大致相同：\n只是第一步先去table里找有无这个page存在，如果没有就类似于NewPgImp() 先找一个frame，然后通过disk_manager_将磁盘的数据读入新页。之后建立新的关系。\nUnpinPgImp（page_id_t page_id, bool is_dirty） 当上层有一个进程在读取这个页的时候这个页都要被pin住不能被淘汰，在使用结束的时候会对该页进行一次unpin的操作，这会使得pin_count_\u0026ndash;，当这个数值为0的时候该页就可被SetEvictable()函数将其在replacer中标记为可淘汰。\n随着page_id一同传进来的还有一个bool变量is_dirty这个变量用来表示使用这个页的进程对这个页干了什么，如果仅仅只是读的话is_dirty的值就为false，但是进行的改动的话is_dirty的值就为true。 需要注意的一定，只有当原来这个页是干净的时候才能进行状态的修改。\nSummary \u0026amp;\u0026amp; 踩坑记录 在task1的时候没有搞懂IndexOf（）函数的作用是什么，看到进行位操作本能的进行回避，导致被卡了好长时间，毫无头绪，在写的时候还是要搞懂细节，多看官方的注释。 SetEvictable（）这个函数中明白curr_size_什么时候能改，什么时候不能改。 在FlushAllPgsImp()中复用了FlushPgImp()函数，导致在线评测虽然样例都过了但是一直超时，最后还是在BusTub Lab1 Buffer Pool Manager | Fischer.space这篇文章中得到启发。总的来说还是多线程编程学的不是很好。 以上三个都是卡我时间比较长而且处理起来毫无头绪的。不过幸好项目用cmake构建，debug起来算是比较方便，帮我节约了很多的时间。\n我认为比较有挑战的就是task1，大的框架建好之后这种修修补补的编程很有意思。相比于有些课程的全面铺开完全从0开始实现，这种直入主题，学习核心思想的过程让我受益匪浅。\n最后附上通过截图，rank比较靠后就不放了，因为全局一把大锁，能跑下来我已经很开心了。\n","permalink":"https://jialog.top/posts/database/project/cmu15-445-project1-buffer-pool-manager/","summary":"\u003ch2 id=\"环境搭建\"\u003e环境搭建\u003c/h2\u003e\n\u003cp\u003e按照P0的指导中进行环境的搭建，由于我本人现在时WIN平台，课程没有提供一键配置环境的脚本，所以我选择云服务器进行环境的构建，很稳。\u003c/p\u003e\n\u003cp\u003e但是我的云服务器配置只有2核2G在编译的时候会爆内存。这里还有个故事，在爆内存之后我已经意识到这个问题，我给阿里云客服提了个工单试图能白嫖一些配置，客服还是很有水平的，直接就分析出来我是内存爆了导致的，但是直接建议我加钱升级配置，不告诉我设置swap分区，有点不厚道了。\u003c/p\u003e\n\u003cp\u003e话说回来，设置完swap分区之后就没有再出现过爆内存的现象。用VScode的远程开发，体验还是很不错的。\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003ep1主要是内存管理部分的内容，这门课程的课本和录制视频还是很有必要看一下的。\u003c/p\u003e\n\u003cp\u003e主要的任务是以下三个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可扩展的哈希表\u003c/li\u003e\n\u003cli\u003eLRU-K的淘汰策略的视线\u003c/li\u003e\n\u003cli\u003eBuffer Pool的一个实例\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在开始梳理项目之前我想要先解释清楚一下三个任务之间的关系，以及各个部分的负责。\u003c/p\u003e\n\u003cp\u003eframe更像是一个\u003cstrong\u003e载体\u003c/strong\u003e，而page是其中的内容。打个比方来说，一个仓库（buffer pool）只有100辆货车（frame），而货物（page）成千上万种，每次都是仓库告诉货车需要什么货物然后由货车带着货物来到仓库，而可扩展的哈希表就是登记货车和货物的\u003cstrong\u003e对应关系\u003c/strong\u003e。因为只有100辆货车，当每辆车都是满的时候（没有闲置的车辆free_list不为空）就需要根据task2的LRU-K算法挑选出一个符合要求的货车清空后去装载指定的货物。\n而task3就是负责整个的管理和交互。\u003c/p\u003e\n\u003cp\u003e大概解释了一下，可能比方不是很恰当，做的时候一定要多看文档和注释，因为漏看注释给我带来了极大的痛苦。\u003c/p\u003e\n\u003ch2 id=\"task-1--extendiblehashtable\"\u003eTask #1 -ExtendibleHashTable\u003c/h2\u003e\n\u003ch3 id=\"相关函数\"\u003e相关函数\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eFind(K,V):\u003c/code\u003e 查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回false\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInsert(K,V):\u003c/code\u003e 插入一个（K，V），如果插入失败需要进行一下步骤的重试：\n\u003col\u003e\n\u003cli\u003e插入失败肯定是桶满了，但是桶满了分为两种不同的情况。\u003c/li\u003e\n\u003cli\u003e一种是global深度和桶的local深度不相同的时候，需要对桶进行重新的分配。\u003c/li\u003e\n\u003cli\u003e当两个深度相同的时候说明桶是真的满了，需要对哈希表进行扩展\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRemove(K):\u003c/code\u003e 在哈希表中移除对应的（K，V）对，但是需要进行哈希表缩小的操作。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIndexOf(K):\u003c/code\u003e  当前global深度下的映射规则。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"项目架构\"\u003e项目架构\u003c/h3\u003e\n\u003cp\u003e首先要清楚这个是自己动手实现一个可扩展哈希表用于保存frame和page的\u003cstrong\u003e映射关系\u003c/strong\u003e的。我觉得首先要明白frame和page之间的关系。不清楚的可以回看上文的解释。\u003c/p\u003e\n\u003ch3 id=\"bucket-存储桶\"\u003eBucket 存储桶\u003c/h3\u003e\n\u003cp\u003e在可可以扩展的哈希表种引入和Bucket的概念，用于解决\u003cstrong\u003e哈希冲突\u003c/strong\u003e的问题，每一个Bucket的大小都是固定的，当一个Bucket满了的时候就需要进行哈希表的\u003cstrong\u003e扩展\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|200\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231205232548.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"bucket的组成\"\u003eBucket的组成\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|325\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231205233054.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003edepth_\u003c/strong\u003e：表示本地深度的一个标识，用于识别当前的深度是否和全局深度相同。要特别注意这个变量。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elist_\u003c/strong\u003e：发生哈希冲突时保存多个（K，V）映射的双向链表。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esize\u003c/strong\u003e：为了保证效率，list的长度不能无限延伸，所以达到一定长度的时候要进行哈希表的扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"可扩展的哈希表结构\"\u003e可扩展的哈希表结构\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|325\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231205234304.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBucket_size:用于限制每个bucket的list的长度\u003c/li\u003e\n\u003cli\u003edir_:用于哈西运算后保存映射关系。\u003c/li\u003e\n\u003cli\u003eglobal_depth_:全局深度，在\u003cstrong\u003e插入\u003c/strong\u003e的时候根据\u003cstrong\u003e全局深度\u003c/strong\u003e和\u003cstrong\u003e局部深度\u003c/strong\u003e来确定这个桶是否要进行重新的分配。\u003c/li\u003e\n\u003cli\u003enum_buckets:用于统计现在一共有多少bucket。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rehash的过程详解\"\u003eReHash的过程详解\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e1.hash的规则是什么样的\u003c/p\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etemplate\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"k\"\u003etypename\u003c/span\u003e \u003cspan class=\"n\"\u003eK\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003etypename\u003c/span\u003e \u003cspan class=\"n\"\u003eV\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eExtendibleHashTable\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eK\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eV\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;::\u003c/span\u003e\u003cspan class=\"n\"\u003eIndexOf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eK\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eglobal_depth_\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eK\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e()(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上述函数就是该哈希表的映射规则，总的来说就是取hash函数值的\u003cstrong\u003e低\u003ccode\u003eglobal_depth\u003c/code\u003e位\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e假如现在global_depth_的值为3。\n那么 \u003ccode\u003e1 \u0026lt;\u0026lt; global_depth_\u003c/code\u003e的值就是8转换为二进制就是 1000 。mask=8-1=7，转换为二进制就是 111.\u003c/p\u003e\n\u003cp\u003emask 的作用就是取一个位数和global_depth_一样的全1的二进制数，为了取低global_depth_位做铺垫。\u003c/p\u003e\n\u003cp\u003e现在假如key的值进行完hash之后是 10110100011010 和 mask进行进行 \u0026amp; 的操作之后就变成了 010 （低3位）\u003c/p\u003e","title":"CMU15-445- Project #1 - Buffer Pool Manager"},{"content":"TABLE INDEX A table index is a replica of a subset of a table\u0026rsquo;s attributes that are organized and/or sorted for efficient access using those attributes.The DBMS ensures that the contents of the table and the index are logically synchronized.\n索引让数据在数据库中的查询更加的高效，DBMS负责使索引和实际内容同步。\nDBMS的工作是选择最优的索引去执行查询，这就带来一个需要权衡的问题——索引越多查询越高效但是相对的维护成本（Maintenance Overhead）和存储成本（Storage Overhead） 就会相应的提高。\nB-TREE FAMILY B-树家族。\n重点了解B+树。\n（B树虽然是一个平衡树（balance），但B树的B不是balance的缩写，到底代表什么还存疑）\nB+TREE B+树是一个自平衡树的数据结构，顺序的存储数据，并且将查询，顺序访问，插入和删除的时间复杂度基本控制在O(log n)。\n是二叉搜索树的推广，因为它可以有超过两个的孩子节点。 它针对系统和存储之间的大块数据读写进行了特别的优化。 B+TREE PROPERTIES B+树是一个多叉搜索树，有以下特性：\n他完美平衡 除了根节点都至少半满 k个值会把一个节点分为k+1部分。 B+TREE EXAMPLE 上图是一个小例子，能够发现B+树底层是能够双向访问的，这在多线程的时候有可能会造成死锁问题。这在后面讲解B+树多线程的章节也会对原因进行讲解。\nB+‘s CRUD 可以说B+树的增删改查的特性和它的组织形式是密不可分的。每次做改动之后都要符合他的结构特性，所以也没什么好说的。\nB+树的一些应用扩展 二级索引 \u0026amp;\u0026amp; 记录迁移 如果二级索引的叶子节点直接指向的是对应数据的指针，那么在发生增删的时候结构发生变化二级索引就需要进行重构，这不仅是一项开销非常大的方法，而且还难以保证数据的同步。\n解决办法: 辅助索引的叶子节点存主键的值列表，这种关系的固定的不会改变的，一两个数据的增删不会造成整个树的重构。\n这就避免了由于重构导致变化而二级索引需要跟着重构的带来的开销。现需要在辅助索引上查到需要的主键列表然后再去主键索引上去查找对应的数据。\n这样虽然降低了查询时候的一点效率，但是跟频繁的重构比起来还是难以感知的😃。\n字符串索引 尽力一个B+树的字符串索引有两个问题：\n字符串一般都是变长的，这很难解决 因为字符串可能会很长，所以扇的出度会降低，相应的树高会变高。 对应的解决办法有以下两点：\n灵活的出度。每个扇的出度并不是简单固定的，根据这个扇的字符串所用的空间进行灵活的调整。 前缀压缩。只用存储到不一样的第一位，能够分辨就够了。 例如，如果我们有一个名称索引，那么非叶节点上的键值可以是名称的前缀；如果它分离的两个子树中最接近的值分别是“Silas”和“Silver”，那么在非叶节点存储“Silb”而不是完整的“Silberschatz”就足够了。这就是前缀压缩\n批量加载B+树索引 前面我们知道B+树的插入操作开销非常的大，一定程度上这个插入的开销和树的高度是成正比的。所以树的高度一般最多被控制在5，对于大型项目也是这样的。\n正因为如此，加入现在有100万条数据需要插入，每条数据光是I/O都需要很长的时间，更不用说插入之后B+树重构的时间。\n现在有一种优化的方法，将需要插入的大量数据进行排序后按照B+树的方法构建索引后将这颗构建的树merge到原来的B+树中，这样做有以下几个好处：\n在多线程方面具有优势 在构建的时候会产生更少的I/O. 叶子节点会按顺序进行排序。 下面是一个用chatgpt写出来的一个b+树的小demo，用来窥探一下具体实现是很有帮助的。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; const int ORDER = 3; // B+树的阶数 // B+树节点 template \u0026lt;typename Key, typename Value\u0026gt; struct BPlusTreeNode { bool isLeaf; std::vector\u0026lt;Key\u0026gt; keys; std::vector\u0026lt;Value\u0026gt; values; BPlusTreeNode* parent; BPlusTreeNode* next; // 用于叶子节点的连接 }; // B+树 template \u0026lt;typename Key, typename Value\u0026gt; class BPlusTree { public: BPlusTree() : root(nullptr) {} void insert(const Key\u0026amp; key, const Value\u0026amp; value) { if (root == nullptr) { root = new BPlusTreeNode\u0026lt;Key, Value\u0026gt;(); root-\u0026gt;isLeaf = true; root-\u0026gt;keys.push_back(key); root-\u0026gt;values.push_back(value); } else { insertHelper(root, key, value); } } Value search(const Key\u0026amp; key) const { return searchHelper(root, key); } void print() const { printHelper(root, 0); } private: BPlusTreeNode\u0026lt;Key, Value\u0026gt;* root; void insertHelper(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node, const Key\u0026amp; key, const Value\u0026amp; value) { if (node-\u0026gt;isLeaf) { insertIntoLeaf(node, key, value); } else { int i = 0; while (i \u0026lt; node-\u0026gt;keys.size() \u0026amp;\u0026amp; key \u0026gt; node-\u0026gt;keys[i]) { i++; } insertHelper(node-\u0026gt;children[i], key, value); } } void insertIntoLeaf(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node, const Key\u0026amp; key, const Value\u0026amp; value) { auto it = std::lower_bound(node-\u0026gt;keys.begin(), node-\u0026gt;keys.end(), key); int index = it - node-\u0026gt;keys.begin(); node-\u0026gt;keys.insert(it, key); node-\u0026gt;values.insert(node-\u0026gt;values.begin() + index, value); if (node-\u0026gt;keys.size() \u0026gt; ORDER - 1) { splitLeaf(node); } } void splitLeaf(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node) { BPlusTreeNode\u0026lt;Key, Value\u0026gt;* newLeaf = new BPlusTreeNode\u0026lt;Key, Value\u0026gt;(); newLeaf-\u0026gt;isLeaf = true; int splitIndex = (ORDER - 1) / 2; newLeaf-\u0026gt;keys.assign(node-\u0026gt;keys.begin() + splitIndex, node-\u0026gt;keys.end()); newLeaf-\u0026gt;values.assign(node-\u0026gt;values.begin() + splitIndex, node-\u0026gt;values.end()); node-\u0026gt;keys.resize(splitIndex); node-\u0026gt;values.resize(splitIndex); newLeaf-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next = newLeaf; insertIntoParent(node, newLeaf-\u0026gt;keys[0], newLeaf); } void insertIntoParent(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* left, const Key\u0026amp; key, BPlusTreeNode\u0026lt;Key, Value\u0026gt;* right) { if (root == left) { BPlusTreeNode\u0026lt;Key, Value\u0026gt;* newRoot = new BPlusTreeNode\u0026lt;Key, Value\u0026gt;(); newRoot-\u0026gt;keys.push_back(key); newRoot-\u0026gt;children.push_back(left); newRoot-\u0026gt;children.push_back(right); left-\u0026gt;parent = newRoot; right-\u0026gt;parent = newRoot; root = newRoot; } else { BPlusTreeNode\u0026lt;Key, Value\u0026gt;* parent = left-\u0026gt;parent; auto it = std::lower_bound(parent-\u0026gt;keys.begin(), parent-\u0026gt;keys.end(), key); int index = it - parent-\u0026gt;keys.begin(); parent-\u0026gt;keys.insert(it, key); parent-\u0026gt;children.insert(parent-\u0026gt;children.begin() + index + 1, right); right-\u0026gt;parent = parent; if (parent-\u0026gt;keys.size() \u0026gt; ORDER - 1) { splitInternal(parent); } } } void splitInternal(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node) { BPlusTreeNode\u0026lt;Key, Value\u0026gt;* newInternal = new BPlusTreeNode\u0026lt;Key, Value\u0026gt;(); int splitIndex = (ORDER - 1) / 2; Key upKey = node-\u0026gt;keys[splitIndex]; newInternal-\u0026gt;keys.assign(node-\u0026gt;keys.begin() + splitIndex + 1, node-\u0026gt;keys.end()); newInternal-\u0026gt;children.assign(node-\u0026gt;children.begin() + splitIndex + 1, node-\u0026gt;children.end()); node-\u0026gt;keys.resize(splitIndex); node-\u0026gt;children.resize(splitIndex + 1); for (auto child : newInternal-\u0026gt;children) { child-\u0026gt;parent = newInternal; } insertIntoParent(node, upKey, newInternal); } Value searchHelper(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node, const Key\u0026amp; key) const { if (node == nullptr) { return Value(); // 返回默认值表示未找到 } int i = 0; while (i \u0026lt; node-\u0026gt;keys.size() \u0026amp;\u0026amp; key \u0026gt; node-\u0026gt;keys[i]) { i++; } if (node-\u0026gt;isLeaf) { if (i \u0026lt; node-\u0026gt;keys.size() \u0026amp;\u0026amp; key == node-\u0026gt;keys[i]) { return node-\u0026gt;values[i]; } else { return Value(); // 返回默认值表示未找到 } } else { return searchHelper(node-\u0026gt;children[i], key); } } void printHelper(BPlusTreeNode\u0026lt;Key, Value\u0026gt;* node, int level) const { if (node != nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;Level \u0026#34; \u0026lt;\u0026lt; level \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int i = 0; i \u0026lt; node-\u0026gt;keys.size(); ++i) { std::cout \u0026lt;\u0026lt; node-\u0026gt;keys[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; if (!node-\u0026gt;isLeaf) { for (auto child : node-\u0026gt;children) { printHelper(child, level + 1); } } } } }; int main() { BPlusTree\u0026lt;int, std::string\u0026gt; bPlusTree; // 插入示例 bPlusTree.insert(10, \u0026#34;Value10\u0026#34;); bPlusTree.insert(20, \u0026#34;Value20\u0026#34;); bPlusTree.insert(5, \u0026#34;Value5\u0026#34;); bPlusTree.insert(6, \u0026#34;Value6\u0026#34;); bPlusTree.insert(12, \u0026#34;Value12\u0026#34;); bPlusTree.insert(30, \u0026#34;Value30\u0026#34;); bPlusTree.insert(7, \u0026#34;Value7\u0026#34;); bPlusTree.insert(17, \u0026#34;Value17\u0026#34;); bPlusTree.insert(25, \u0026#34;Value25\u0026#34;); // 打印B+树 bPlusTree.print(); // 搜索示例 int keyToSearch = 12; std:: 多线程的B+树 Locks\u0026amp;\u0026amp;Latches ==两者区别==\n个人认为是存在的维度不太一样。locks适用于宏观方面的，latches则是细致入微的。 （剩下的还待总结、、、体会确实没有那么的深刻😀），不过可以参考chatgpt说的。 ==读模式和写模式==\n读模式比较随意，因为不涉及修改所以谁读都无所谓，只是在读的时候不能修改 写模式因为涉及到修改，所以只有唯一的一个线程能够进行写。 这张图可以解释latch的正常运行的逻辑。 Latches的实现 ==方法一==\n这三种“mutex”有何区别。\n==方法二==\n允许多线程读，读的时候如果有写🔒需要让写锁等待，之后要用公平的算法平衡，防止某个线程饿死。 可以基于自旋锁实现。 Latches的应用 ==hash table latches== 因为哈希表的搜索方向是朝向同一个方向，在搜索的时候只涉及到一个数据页或行 不会发生搜索冲突的现象，因此不可能发生死锁 在resize哈希表的时候在header page上🔒一下，就能保证整个hash表的写锁。 ==实现==\n在每个页或者每一行上加上这种细粒度的锁自然是有助于效率的提升 在搜寻到下一页的时候上一页处于什么状态已经没有任何关系了，所以可以放心的释放锁 这是另一种粒度更细的锁，在每一行数据上加锁，搜索到下一行就给上一行解锁。 b+ tree latches ==螃蟹锁==\n在读的时候：当获取到下一个page的读锁之后就可以释放当前page的读锁。 在写的时候：一直递归向下获取写锁，直到碰到一个page是处于安全状态的，就可以释放所有父节点的写锁。（悲观锁） 在写的时候：先假设一路上的节点都是处于安全状态的，如果发现有不安全的那么就推到按照悲观锁的方法再来一遍。 ","permalink":"https://jialog.top/posts/database/note/b+-tree-index/","summary":"\u003ch2 id=\"table-index\"\u003eTABLE INDEX\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA table index is a replica of a subset of a table\u0026rsquo;s attributes that are organized and/or sorted for efficient access using those attributes.The DBMS ensures that the contents of the table and the index are logically synchronized.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e索引\u003c/strong\u003e让数据在数据库中的查询更加的高效，DBMS负责使索引和实际内容\u003cstrong\u003e同步\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|575\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231208203437.png\"\u003e\u003c/p\u003e\n\u003cp\u003eDBMS的工作是选择最优的索引去执行查询，这就带来一个需要权衡的问题——索引越多查询越高效但是相对的\u003cstrong\u003e维护成本\u003c/strong\u003e（Maintenance Overhead）和\u003cstrong\u003e存储成本\u003c/strong\u003e（Storage Overhead） 就会相应的提高。\u003c/p\u003e\n\u003ch2 id=\"b-tree-family\"\u003eB-TREE FAMILY\u003c/h2\u003e\n\u003cp\u003eB-树家族。\u003c/p\u003e\n\u003cp\u003e重点了解B+树。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231208214614.png\"\u003e\u003c/p\u003e\n\u003cp\u003e（B树虽然是一个平衡树（balance），但B树的B不是balance的缩写，到底代表什么还存疑）\u003c/p\u003e\n\u003ch3 id=\"btree\"\u003eB+TREE\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|600\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231208215020.png\"\u003e\u003c/p\u003e\n\u003cp\u003eB+树是一个自平衡树的数据结构，\u003cstrong\u003e顺序的\u003c/strong\u003e存储数据，并且将查询，顺序访问，插入和删除的时间复杂度基本控制在\u003cstrong\u003eO(log n)\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是二叉搜索树的推广，因为它可以有超过两个的孩子节点。\u003c/li\u003e\n\u003cli\u003e它针对系统和存储之间的大块数据读写进行了特别的优化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"btree-properties\"\u003eB+TREE PROPERTIES\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231208220751.png\"\u003e\u003c/p\u003e\n\u003cp\u003eB+树是一个多叉搜索树，有以下特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e他完美平衡\u003c/li\u003e\n\u003cli\u003e除了根节点都至少半满\u003c/li\u003e\n\u003cli\u003ek个值会把一个节点分为k+1部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"btree-example\"\u003eB+TREE EXAMPLE\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|675\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231208223923.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是一个小例子，能够发现B+树底层是能够双向访问的，这在\u003cstrong\u003e多线程\u003c/strong\u003e的时候有可能会造成\u003cstrong\u003e死锁\u003c/strong\u003e问题。这在后面讲解B+树多线程的章节也会对原因进行讲解。\u003c/p\u003e","title":"B+ Tree Index"},{"content":"CMU15-445 作为 CMU 数据库的入门课，这门课由数据库领域的大牛 Andy Pavlo 讲授（“这个世界上我只在乎两件事，一是我的老婆，二就是数据库”）。\n这是一门质量极高，资源极齐全的 Database 入门课，这门课的 Faculty 和背后的 CMU Database Group 将课程对应的基础设施 (Autograder, Discord) 和课程资料 (Lectures, Notes, Homework) 完全开源，让每一个愿意学习数据库的同学都可以享受到几乎等同于 CMU 本校学生的课程体验。\n亮点在于这门课程实现了一个关系型数据库的Demo\u0026ndash;bustub，并对组成部分进行修改，最后达到完成整个数据库的目的，非常的有意思。\n近年来由于CMU15-445这门课的热度大增，无论是找工作还是保研的简历上都少不了这个课程。到了可以说是人手一个的地步（还有MIT6.824），但是最后的排行榜上真正完成4个项目并且有成绩的不过100余人。在这种背景下也催生出了很多卖课的机构和个人。还有种种乱象。暂且按下不表，进入主题。\n前言 先附上 课程链接我原本是想要完成最新的课程即2023fall的，但是2023fall的P0直接就把我劝退了，相较于2022fall的P0我认为难度上升了不止一点。但是其他的Project的实现差别并不是太大，所以我选择了较为容易下手的2022fall的课程进行学习。\nProject0-C++ Primer 还是先放上项目Project#0-C++primer链接\n概述 这是一个相当于先导课程的项目，旨在培养和检验学生的现代C++编程能力 ，BusTub大量使用C++17，当你上手之后可能就会发现和你印象中的C++不一样。\n在CMU如果你没能满分通过P0，那么你会被要求退课。 所需前置知识 我认为需要的前置知识主要包括C++11的新特性 这是在2023fall课程的一个可能是助教写的一个小demo包含了几个例子能够帮助你快速的上手c++11的新特性。\n熟悉字典树能够理解字典树原理能够完成一个字典树的小demoLeetCode.208实现前缀字典树 可以先把这个做了，了解一下什么是字典树。\n上图就是一个字典树的简单示意图\n文件结构 在文件中作为字典树的架子文件中包含了三个类。\nTrieNode TrieNodeWithValue Trie Task#1 字典树 先完成一个单线程版本的字典树，后期再考虑并发。\nTrieNode TrieNode定义了一个Trie树的一个节点。 一个包含关键字的char类型`key_char_。 一个bool类型is_node的标志来标记这个节点是否是值节点 包含一个存储类型为 char to unique_ptr\u0026lt;TrieNode\u0026gt;映射的哈希表 需要注意的点： C++中智能指针std::unique_ptr的特性所带来的： The InsertChildNode and GetChildNode both return a pointer to unique_ptr 这个独享类型的智能指针也不支持被复制，所以要么使用std::move()把所有权交出去，要么就用get()函数把裸指针交出去。 the move constructor TrieNode(TrieNode \u0026amp;\u0026amp;other_trie_node) is used to transfer old TrieNode\u0026rsquo;s unique pointers to a new TrieNode。因为是unique_ptr所以在传递的时候不能对指针进行复制。（解决方法就是使用move()函数）。 TrieNodeWithValue 这个是[[CMU15-445 Project 0 - C++ Primer#TrieNode]]类的子类，多了一个能保存任意类型的值T。而且is_end被设定为True。 根据不同的情况调用不同的构造函数。如果原本是一个普通节点就调用参数为（TrieNode\u0026amp;\u0026amp;，T），如果是创建一个全新的节点则调用参数为(char,T). Trie Class 有一个root_节点，是整个树的根节点，而且不存储任何的值。 Insert 要插入到trie中，您需要首先使用给定的键遍历trie，如果不存在，则插入TrieNode。请注意，不允许插入重复的键，并且应该返回false。一旦到达键的结束字符，有三种可能性：\n到达的节点不存在，需要调用参数为(char,T)的构造函数构造一个全新的值节点。利用“Make use of the fact that a unique_ptr to TrieNode can also store a unique_ptr to TrieNodeWithValue”这一特性可以以最后一个节点为模板（无论是不是值节点都能够成功创建）创建一个新的值节点。 到达的节点存在但不是值节点，调用（TrieNode\u0026amp;\u0026amp;，T）为参数的这样一个转换的构造函数，把普通节点转换为值节点。 存在且是值节点，直接返回false。 Remove 我认为Remove()是这几个函数中相对来说比较难的，因为涉及到递归删除。\n目的就是删除给定路径的节点的值。\nkey不存在直接返回 把终端节点的is_end_的值指定为false。 如果一个节点没有任何孩子那就应该把他删除 遍历trie并递归删除没有子节点的节点。遇到包含子节点的节点时停止。 GetValue 没找到或者类型不匹配将success的值设置为false。 个人认为这个的关键点在于节点类型的转换从而获取到节点的值，又因为current是unique_ptr类型所以只能用get()先获取裸指针再进行转换。\nTask #2 - 多线程字典树 简单概括就是涉及读的操作就上读锁，涉及写的操作就上写锁，涉及读写的操作就上读写锁 千万别忘记返回直接解锁，以免造成死锁。 最后附上通过截图。\n","permalink":"https://jialog.top/posts/database/project/cmu15-445-project-0---c++-primer/","summary":"\u003ch1 id=\"cmu15-445\"\u003eCMU15-445\u003c/h1\u003e\n\u003cp\u003e作为 CMU 数据库的入门课，这门课由数据库领域的大牛 Andy Pavlo 讲授（“这个世界上我只在乎两件事，一是我的老婆，二就是数据库”）。\u003c/p\u003e\n\u003cp\u003e这是一门质量极高，资源极齐全的 Database 入门课，这门课的 Faculty 和背后的 CMU Database Group 将课程对应的基础设施 (Autograder, Discord) 和课程资料 (Lectures, Notes, Homework) 完全开源，让每一个愿意学习数据库的同学都可以享受到几乎等同于 CMU 本校学生的课程体验。\u003c/p\u003e\n\u003cp\u003e亮点在于这门课程实现了一个关系型数据库的Demo\u0026ndash;bustub，并对组成部分进行修改，最后达到完成整个数据库的目的，非常的有意思。\u003c/p\u003e\n\u003cp\u003e近年来由于CMU15-445这门课的热度大增，无论是找工作还是保研的简历上都少不了这个课程。到了可以说是人手一个的地步（还有MIT6.824），但是最后的排行榜上真正完成4个项目并且有成绩的不过100余人。在这种背景下也催生出了很多卖课的机构和个人。还有种种乱象。暂且按下不表，进入主题。\u003c/p\u003e\n\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e先附上 \u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022\"\u003e课程链接\u003c/a\u003e我原本是想要完成最新的课程即2023fall的，但是2023fall的P0直接就把我劝退了，相较于2022fall的P0我认为难度上升了不止一点。但是其他的Project的实现差别并不是太大，所以我选择了较为容易下手的2022fall的课程进行学习。\u003c/p\u003e\n\u003ch1 id=\"project0-c-primer\"\u003eProject0-C++ Primer\u003c/h1\u003e\n\u003cp\u003e还是先放上\u003ca href=\"https://15445.courses.cs.cmu.edu/fall2022/project0/\"\u003e项目Project#0-C++primer链接\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e这是一个相当于先导课程的项目，\u003cstrong\u003e旨在培养和检验学生的现代C++编程能力\u003c/strong\u003e ，BusTub大量使用C++17，当你上手之后\u003cstrong\u003e可能\u003c/strong\u003e就会发现和你印象中的C++不一样。\u003c/p\u003e\n\u003cp\u003e在CMU如果你没能满分通过P0，那么你会被要求退课。\n\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129141237.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"所需前置知识\"\u003e所需前置知识\u003c/h2\u003e\n\u003cp\u003e我认为需要的前置知识主要包括\u003ca href=\"https://github.com/cmu-db/15445-bootcamp\"\u003e\u003cstrong\u003eC++11的新特性\u003c/strong\u003e\u003c/a\u003e\n这是在2023fall课程的一个可能是助教写的一个小demo包含了几个例子能够帮助你快速的上手c++11的新特性。\u003c/p\u003e\n\u003cp\u003e熟悉\u003cstrong\u003e字典树\u003c/strong\u003e能够理解字典树原理能够完成一个字典树的小demo\u003ca href=\"https://leetcode.cn/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode.208实现前缀字典树\u003c/a\u003e 可以先把这个做了，了解一下什么是字典树。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129144859.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图就是一个字典树的简单示意图\u003c/p\u003e\n\u003ch2 id=\"文件结构\"\u003e文件结构\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"image.png|264\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129162120.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在文件中作为字典树的架子文件中包含了三个类。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrieNode\u003c/li\u003e\n\u003cli\u003eTrieNodeWithValue\u003c/li\u003e\n\u003cli\u003eTrie\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"task1-字典树\"\u003eTask#1 字典树\u003c/h2\u003e\n\u003cp\u003e先完成一个单线程版本的字典树，后期再考虑并发。\u003c/p\u003e\n\u003ch3 id=\"trienode\"\u003eTrieNode\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTrieNode\u003c/code\u003e定义了一个Trie树的一个节点。\n\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129160311.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个包含关键字的char类型`key_char_。\u003c/li\u003e\n\u003cli\u003e一个bool类型\u003ccode\u003eis_node\u003c/code\u003e的标志来标记这个节点是否是\u003cstrong\u003e值节点\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e包含一个存储类型为 \u003ccode\u003echar\u003c/code\u003e to \u003ccode\u003eunique_ptr\u0026lt;TrieNode\u0026gt;\u003c/code\u003e映射的哈希表\n\u003cstrong\u003e需要注意的点：\u003c/strong\u003e\nC++中智能指针\u003ca href=\"https://www.learncpp.com/cpp-tutorial/stdunique_ptr/\"\u003estd::unique_ptr的特性\u003c/a\u003e所带来的：\nThe \u003ccode\u003eInsertChildNode\u003c/code\u003e and \u003ccode\u003eGetChildNode\u003c/code\u003e both return a pointer to \u003ccode\u003eunique_ptr\u003c/code\u003e\n这个独享类型的智能指针也不支持被复制，所以要么使用\u003ccode\u003estd::move()\u003c/code\u003e把所有权交出去，要么就用\u003ccode\u003eget()\u003c/code\u003e函数把裸指针交出去。\nthe move constructor \u003ccode\u003eTrieNode(TrieNode \u0026amp;\u0026amp;other_trie_node)\u003c/code\u003e is used to transfer old TrieNode\u0026rsquo;s unique pointers to a new TrieNode。因为是unique_ptr所以在传递的时候不能对指针进行复制。（解决方法就是使用move()函数）。\n\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129173037.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/20231129173224.png\"\u003e\u003c/p\u003e","title":"CMU15-445- Project #0 - C++ Primer"},{"content":"","permalink":"https://jialog.top/essay/321/","summary":"","title":""},{"content":"麻雀虽小五脏俱全的一个小而全的类unix教学用操作系统，由MIT开发\n多核的操作系统，大约6000行还有大约300行的汇编，代码简洁易懂，有很多设计都值得借鉴。\n一些特性 有进程管理功能 有虚拟地址和空间，pagetable 文件系统 时间片 21个syscall 用户程序 sh cat echo grep kill 能够被视为一个真正的操作系统\n缺失的功能 用户ID 登录功能 文件保护 虚拟内存 无法联网 只有两个设备驱动 xv6特性 SMP 多线程共享内存 设备 UART 发送字节流，从一端到另一端 disk 磁盘驱动器 定时器 PLIC 平台级中断控制器，哪个核心应该被告诉中断 CLINT 本地中断控制器 内存管理 pagesize 4096B 一个freelist 没有可变的内存分配 没有“malloc” 三级页表 sv39，在pgtbl 巨页中有用到 调度器 基本的循环调度 时间片的大小是固定的 所有的核心共享一个就绪队列，循环的寻找可以执行的进程 不是完全的循环，如果在时间片内结束，会把这个进程放进队列然后换一个来\n启动顺序 加载核心代码到固定的地址0x8000_0000,没有bios，bootloader bootblock\n锁 自旋锁，sleep（），wakeup（） param.h 用户地址空间 函数的参数将会被放在栈中。\nxv6的虚拟地址 sv39，三级页表之地 实际上xv6只使用了38位所以最大的是256GB\nxv6启动过程和组织 控制权逐步的转移\n数据的类型 自旋锁 循环不断的检查，直到能够获取锁为止 test and set，原子的操作。 释放的时候直接修改值就行，可能看起来不是很原子，但是在内存里这被视为一个单独的操作。\n不应该长时间被持有，获取锁之后应该尽快释放。可以使用sleep和wakeup进行长时间的获取锁。\n一个使用自旋锁的例子 buffer pushoff popoff 内存管理 kalloc and kfree 将在初始化的时候第一个使用\n系统调用 在用户模式下 ==kill（）== risc-v架构 寄存器 一共32个寄存器 a0用于存放返回函数返回值\n三种模式 机器模式（machine mode），是最高权限的模式，但是用的并不多，基本是两种情况，一个是启动和初始化，另一个是定时器中断，程序会很快的转变为对supervisor mode的中断。 supervisor mode，所有的内核态代码和一些特权指令（只能在S 和M模式下执行的）。 用户模式，我们可以说在supervisor 模式下运行的代码都是核心代码，反之亦然 19个寄存器 页表结构 更改satp的时候需要更新flash\n只用了38位\n在user mode下 在机器模式下 上下文切换 trapfram 和trampoline 调度函数 switch.s UART.C 16550a芯片与外部设备进行交互\n虚拟内存的操作函数 页表结构 一个页表树 标志位只在最后一级页表是最重要的，前两级都只有有效位是有用的，其他都为0.\n一些函数 ==walk（）==\n返回页表项的地址。\n==mappages（）==\n==walkaddr（）== 把虚拟地址转换成物理地址。 必须是可用的而且是 用户页 ","permalink":"https://jialog.top/posts/os/xv6%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003e麻雀虽小五脏俱全的一个小而全的类unix教学用操作系统，由MIT开发\u003c/p\u003e\n\u003cp\u003e多核的操作系统，大约6000行还有大约300行的汇编，代码简洁易懂，有很多设计都值得借鉴。\u003c/p\u003e\n\u003ch2 id=\"一些特性\"\u003e一些特性\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e有进程管理功能\u003c/li\u003e\n\u003cli\u003e有虚拟地址和空间，pagetable\u003c/li\u003e\n\u003cli\u003e文件系统\u003c/li\u003e\n\u003cli\u003e时间片\u003c/li\u003e\n\u003cli\u003e21个syscall\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"用户程序\"\u003e用户程序\u003c/h3\u003e\n\u003cp\u003esh cat echo grep kill\n能够被视为一个真正的操作系统\u003c/p\u003e\n\u003ch3 id=\"缺失的功能\"\u003e缺失的功能\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e用户ID\u003c/li\u003e\n\u003cli\u003e登录功能\u003c/li\u003e\n\u003cli\u003e文件保护\u003c/li\u003e\n\u003cli\u003e虚拟内存\u003c/li\u003e\n\u003cli\u003e无法联网\u003c/li\u003e\n\u003cli\u003e只有两个设备驱动\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"xv6特性\"\u003exv6特性\u003c/h2\u003e\n\u003ch3 id=\"smp-多线程共享内存\"\u003eSMP 多线程共享内存\u003c/h3\u003e\n\u003ch3 id=\"设备\"\u003e设备\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUART 发送字节流，从一端到另一端\u003c/li\u003e\n\u003cli\u003edisk 磁盘驱动器\u003c/li\u003e\n\u003cli\u003e定时器\u003c/li\u003e\n\u003cli\u003ePLIC 平台级中断控制器，哪个核心应该被告诉中断\u003c/li\u003e\n\u003cli\u003eCLINT 本地中断控制器\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"内存管理\"\u003e内存管理\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003epagesize 4096B\u003c/li\u003e\n\u003cli\u003e一个freelist\u003c/li\u003e\n\u003cli\u003e没有可变的内存分配\u003c/li\u003e\n\u003cli\u003e没有“malloc”\u003c/li\u003e\n\u003cli\u003e三级页表 sv39，在pgtbl 巨页中有用到\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"调度器\"\u003e调度器\u003c/h3\u003e\n\u003cp\u003e基本的循环调度\n时间片的大小是固定的\n所有的核心共享一个就绪队列，循环的寻找可以执行的进程\n不是完全的循环，如果在时间片内结束，会把这个进程放进队列然后换一个来\u003c/p\u003e\n\u003ch3 id=\"启动顺序\"\u003e启动顺序\u003c/h3\u003e\n\u003cp\u003e加载核心代码到固定的地址0x8000_0000,没有bios，bootloader bootblock\u003c/p\u003e\n\u003ch3 id=\"锁\"\u003e锁\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e自旋锁，sleep（），wakeup（）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"paramh\"\u003eparam.h\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-03-21_15-04-00.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_15-04-00.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"用户地址空间\"\u003e用户地址空间\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-03-21_14-48-26.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_14-48-26.png\"\u003e\u003c/p\u003e\n\u003cp\u003e函数的参数将会被放在栈中。\u003c/p\u003e\n\u003ch3 id=\"xv6的虚拟地址\"\u003exv6的虚拟地址\u003c/h3\u003e\n\u003cp\u003esv39，三级页表之地\n\u003cimg alt=\"PixPin_2025-03-21_14-54-26.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_14-54-26.png\"\u003e\n\u003cimg alt=\"PixPin_2025-03-21_14-55-13.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_14-55-13.png\"\u003e\n实际上xv6只使用了38位所以最大的是256GB\u003c/p\u003e\n\u003ch2 id=\"xv6启动过程和组织\"\u003exv6启动过程和组织\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-03-21_14-56-23.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_14-56-23.png\"\u003e\n\u003cimg alt=\"PixPin_2025-03-21_14-57-53.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_14-57-53.png\"\u003e\n控制权逐步的转移\u003c/p\u003e\n\u003ch3 id=\"数据的类型\"\u003e数据的类型\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-03-21_15-03-25.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_15-03-25.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"自旋锁\"\u003e自旋锁\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"PixPin_2025-03-21_15-05-59.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_15-05-59.png\"\u003e\n循环不断的检查，直到能够获取锁为止\n\u003cimg alt=\"PixPin_2025-03-21_15-08-52.png|550\" loading=\"lazy\" src=\"https://weijiale.oss-cn-shanghai.aliyuncs.com/picgo/PixPin_2025-03-21_15-08-52.png\"\u003e\ntest and set，原子的操作。\n释放的时候直接修改值就行，可能看起来不是很原子，但是在内存里这被视为一个单独的操作。\u003c/p\u003e","title":""}]